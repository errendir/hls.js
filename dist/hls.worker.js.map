{"version":3,"file":"hls.worker.js.map","sources":["src/events.ts","src/errors.ts","src/crypt/aes-crypto.ts","src/crypt/fast-aes-key.ts","src/utils/typed-array.ts","src/crypt/aes-decryptor.ts","src/utils/logger.ts","src/polyfills/number.ts","node_modules/url-toolkit/src/url-toolkit.js","src/demux/id3.ts","src/utils/mp4-tools.ts","src/crypt/decrypter.ts","src/types/demuxer.ts","src/demux/dummy-demuxed-track.ts","src/demux/base-audio-demuxer.ts","src/demux/mpegaudio.ts","src/demux/mp3demuxer.ts","src/remux/aac-helper.ts","src/remux/mp4-generator.ts","src/types/loader.ts","src/utils/timescale-conversion.ts","src/remux/mp4-remuxer.ts","src/demux/transmuxer.ts","node_modules/eventemitter3/index.js","src/demux/transmuxer-worker.ts"],"sourcesContent":["import {\n  ManifestLoadedData,\n  ManifestLoadingData,\n  MediaAttachedData,\n  MediaAttachingData,\n  LevelLoadingData,\n  LevelLoadedData,\n  ManifestParsedData,\n  LevelUpdatedData,\n  LevelsUpdatedData,\n  FragParsingUserdataData,\n  FragDecryptedData,\n  FragLoadedData,\n  InitPTSFoundData,\n  CuesParsedData,\n  SubtitleFragProcessedData,\n  NonNativeTextTracksData,\n  FragLoadingData,\n  AudioTrackLoadedData,\n  SubtitleTrackLoadedData,\n  ErrorData,\n  AudioTrackSwitchingData,\n  AudioTrackSwitchedData,\n  KeyLoadedData,\n  KeyLoadingData,\n  SubtitleTrackSwitchData,\n  SubtitleTracksUpdatedData,\n  LevelSwitchedData,\n  FragChangedData,\n  BufferAppendingData,\n  BufferCodecsData,\n  FragParsingMetadataData,\n  FragParsingInitSegmentData,\n  FragBufferedData,\n  BufferFlushingData,\n  BufferEOSData,\n  LevelSwitchingData,\n  FPSDropLevelCappingData,\n  FPSDropData,\n  BufferCreatedData,\n  BufferAppendedData,\n  LevelPTSUpdatedData,\n  FragParsedData,\n  AudioTracksUpdatedData,\n  FragLoadEmergencyAbortedData,\n  BackBufferData,\n  LiveBackBufferData,\n  TrackLoadingData,\n  BufferFlushedData,\n} from './types/events';\n\nexport enum Events {\n  // Fired before MediaSource is attaching to media element\n  MEDIA_ATTACHING = 'hlsMediaAttaching',\n  // Fired when MediaSource has been successfully attached to media element\n  MEDIA_ATTACHED = 'hlsMediaAttached',\n  // Fired before detaching MediaSource from media element\n  MEDIA_DETACHING = 'hlsMediaDetaching',\n  // Fired when MediaSource has been detached from media element\n  MEDIA_DETACHED = 'hlsMediaDetached',\n  // Fired when the buffer is going to be reset\n  BUFFER_RESET = 'hlsBufferReset',\n  // Fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}\n  BUFFER_CODECS = 'hlsBufferCodecs',\n  // fired when sourcebuffers have been created - data: { tracks : tracks }\n  BUFFER_CREATED = 'hlsBufferCreated',\n  // fired when we append a segment to the buffer - data: { segment: segment object }\n  BUFFER_APPENDING = 'hlsBufferAppending',\n  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}\n  BUFFER_APPENDED = 'hlsBufferAppended',\n  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }\n  BUFFER_EOS = 'hlsBufferEos',\n  // fired when the media buffer should be flushed - data { startOffset, endOffset }\n  BUFFER_FLUSHING = 'hlsBufferFlushing',\n  // fired when the media buffer has been flushed - data: { }\n  BUFFER_FLUSHED = 'hlsBufferFlushed',\n  // fired to signal that a manifest loading starts - data: { url : manifestURL}\n  MANIFEST_LOADING = 'hlsManifestLoading',\n  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks ], url : manifestURL, stats : LoaderStats }\n  MANIFEST_LOADED = 'hlsManifestLoaded',\n  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}\n  MANIFEST_PARSED = 'hlsManifestParsed',\n  // fired when a level switch is requested - data: { level : id of new level }\n  LEVEL_SWITCHING = 'hlsLevelSwitching',\n  // fired when a level switch is effective - data: { level : id of new level }\n  LEVEL_SWITCHED = 'hlsLevelSwitched',\n  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}\n  LEVEL_LOADING = 'hlsLevelLoading',\n  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : LoaderStats }\n  LEVEL_LOADED = 'hlsLevelLoaded',\n  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }\n  LEVEL_UPDATED = 'hlsLevelUpdated',\n  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }\n  LEVEL_PTS_UPDATED = 'hlsLevelPtsUpdated',\n  // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }\n  LEVELS_UPDATED = 'hlsLevelsUpdated',\n  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }\n  AUDIO_TRACKS_UPDATED = 'hlsAudioTracksUpdated',\n  // fired when an audio track switching is requested - data: { id : audio track id }\n  AUDIO_TRACK_SWITCHING = 'hlsAudioTrackSwitching',\n  // fired when an audio track switch actually occurs - data: { id : audio track id }\n  AUDIO_TRACK_SWITCHED = 'hlsAudioTrackSwitched',\n  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }\n  AUDIO_TRACK_LOADING = 'hlsAudioTrackLoading',\n  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : LoaderStats }\n  AUDIO_TRACK_LOADED = 'hlsAudioTrackLoaded',\n  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }\n  SUBTITLE_TRACKS_UPDATED = 'hlsSubtitleTracksUpdated',\n  // fired to notify that subtitle tracks were cleared as a result of stopping the media\n  SUBTITLE_TRACKS_CLEARED = 'hlsSubtitleTracksCleared',\n  // fired when an subtitle track switch occurs - data: { id : subtitle track id }\n  SUBTITLE_TRACK_SWITCH = 'hlsSubtitleTrackSwitch',\n  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }\n  SUBTITLE_TRACK_LOADING = 'hlsSubtitleTrackLoading',\n  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : LoaderStats }\n  SUBTITLE_TRACK_LOADED = 'hlsSubtitleTrackLoaded',\n  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }\n  SUBTITLE_FRAG_PROCESSED = 'hlsSubtitleFragProcessed',\n  // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }\n  CUES_PARSED = 'hlsCuesParsed',\n  // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }\n  NON_NATIVE_TEXT_TRACKS_FOUND = 'hlsNonNativeTextTracksFound',\n  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, timescale: timescale, frag : fragment object }\n  INIT_PTS_FOUND = 'hlsInitPtsFound',\n  // fired when a fragment loading starts - data: { frag : fragment object }\n  FRAG_LOADING = 'hlsFragLoading',\n  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }\n  // FRAG_LOAD_PROGRESS = 'hlsFragLoadProgress',\n  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }\n  FRAG_LOAD_EMERGENCY_ABORTED = 'hlsFragLoadEmergencyAborted',\n  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : LoaderStats }\n  FRAG_LOADED = 'hlsFragLoaded',\n  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }\n  FRAG_DECRYPTED = 'hlsFragDecrypted',\n  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }\n  FRAG_PARSING_INIT_SEGMENT = 'hlsFragParsingInitSegment',\n  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }\n  FRAG_PARSING_USERDATA = 'hlsFragParsingUserdata',\n  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }\n  FRAG_PARSING_METADATA = 'hlsFragParsingMetadata',\n  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}\n  // FRAG_PARSING_DATA = 'hlsFragParsingData',\n  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }\n  FRAG_PARSED = 'hlsFragParsed',\n  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : LoaderStats }\n  FRAG_BUFFERED = 'hlsFragBuffered',\n  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }\n  FRAG_CHANGED = 'hlsFragChanged',\n  // Identifier for a FPS drop event - data: { currentDropped, currentDecoded, totalDroppedFrames }\n  FPS_DROP = 'hlsFpsDrop',\n  // triggered when FPS drop triggers auto level capping - data: { level, droppedLevel }\n  FPS_DROP_LEVEL_CAPPING = 'hlsFpsDropLevelCapping',\n  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }\n  ERROR = 'hlsError',\n  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }\n  DESTROYING = 'hlsDestroying',\n  // fired when a decrypt key loading starts - data: { frag : fragment object }\n  KEY_LOADING = 'hlsKeyLoading',\n  // fired when a decrypt key loading is completed - data: { frag : fragment object, keyInfo : KeyLoaderInfo }\n  KEY_LOADED = 'hlsKeyLoaded',\n  // deprecated; please use BACK_BUFFER_REACHED - data : { bufferEnd: number }\n  LIVE_BACK_BUFFER_REACHED = 'hlsLiveBackBufferReached',\n  // fired when the back buffer is reached as defined by the backBufferLength config option - data : { bufferEnd: number }\n  BACK_BUFFER_REACHED = 'hlsBackBufferReached',\n}\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\nexport interface HlsListeners {\n  [Events.MEDIA_ATTACHING]: (\n    event: Events.MEDIA_ATTACHING,\n    data: MediaAttachingData\n  ) => void;\n  [Events.MEDIA_ATTACHED]: (\n    event: Events.MEDIA_ATTACHED,\n    data: MediaAttachedData\n  ) => void;\n  [Events.MEDIA_DETACHING]: (event: Events.MEDIA_DETACHING) => void;\n  [Events.MEDIA_DETACHED]: (event: Events.MEDIA_DETACHED) => void;\n  [Events.BUFFER_RESET]: (event: Events.BUFFER_RESET) => void;\n  [Events.BUFFER_CODECS]: (\n    event: Events.BUFFER_CODECS,\n    data: BufferCodecsData\n  ) => void;\n  [Events.BUFFER_CREATED]: (\n    event: Events.BUFFER_CREATED,\n    data: BufferCreatedData\n  ) => void;\n  [Events.BUFFER_APPENDING]: (\n    event: Events.BUFFER_APPENDING,\n    data: BufferAppendingData\n  ) => void;\n  [Events.BUFFER_APPENDED]: (\n    event: Events.BUFFER_APPENDED,\n    data: BufferAppendedData\n  ) => void;\n  [Events.BUFFER_EOS]: (event: Events.BUFFER_EOS, data: BufferEOSData) => void;\n  [Events.BUFFER_FLUSHING]: (\n    event: Events.BUFFER_FLUSHING,\n    data: BufferFlushingData\n  ) => void;\n  [Events.BUFFER_FLUSHED]: (\n    event: Events.BUFFER_FLUSHED,\n    data: BufferFlushedData\n  ) => void;\n  [Events.MANIFEST_LOADING]: (\n    event: Events.MANIFEST_LOADING,\n    data: ManifestLoadingData\n  ) => void;\n  [Events.MANIFEST_LOADED]: (\n    event: Events.MANIFEST_LOADED,\n    data: ManifestLoadedData\n  ) => void;\n  [Events.MANIFEST_PARSED]: (\n    event: Events.MANIFEST_PARSED,\n    data: ManifestParsedData\n  ) => void;\n  [Events.LEVEL_SWITCHING]: (\n    event: Events.LEVEL_SWITCHING,\n    data: LevelSwitchingData\n  ) => void;\n  [Events.LEVEL_SWITCHED]: (\n    event: Events.LEVEL_SWITCHED,\n    data: LevelSwitchedData\n  ) => void;\n  [Events.LEVEL_LOADING]: (\n    event: Events.LEVEL_LOADING,\n    data: LevelLoadingData\n  ) => void;\n  [Events.LEVEL_LOADED]: (\n    event: Events.LEVEL_LOADED,\n    data: LevelLoadedData\n  ) => void;\n  [Events.LEVEL_UPDATED]: (\n    event: Events.LEVEL_UPDATED,\n    data: LevelUpdatedData\n  ) => void;\n  [Events.LEVEL_PTS_UPDATED]: (\n    event: Events.LEVEL_PTS_UPDATED,\n    data: LevelPTSUpdatedData\n  ) => void;\n  [Events.LEVELS_UPDATED]: (\n    event: Events.LEVELS_UPDATED,\n    data: LevelsUpdatedData\n  ) => void;\n  [Events.AUDIO_TRACKS_UPDATED]: (\n    event: Events.AUDIO_TRACKS_UPDATED,\n    data: AudioTracksUpdatedData\n  ) => void;\n  [Events.AUDIO_TRACK_SWITCHING]: (\n    event: Events.AUDIO_TRACK_SWITCHING,\n    data: AudioTrackSwitchingData\n  ) => void;\n  [Events.AUDIO_TRACK_SWITCHED]: (\n    event: Events.AUDIO_TRACK_SWITCHED,\n    data: AudioTrackSwitchedData\n  ) => void;\n  [Events.AUDIO_TRACK_LOADING]: (\n    event: Events.AUDIO_TRACK_LOADING,\n    data: TrackLoadingData\n  ) => void;\n  [Events.AUDIO_TRACK_LOADED]: (\n    event: Events.AUDIO_TRACK_LOADED,\n    data: AudioTrackLoadedData\n  ) => void;\n  [Events.SUBTITLE_TRACKS_UPDATED]: (\n    event: Events.SUBTITLE_TRACKS_UPDATED,\n    data: SubtitleTracksUpdatedData\n  ) => void;\n  [Events.SUBTITLE_TRACKS_CLEARED]: (\n    event: Events.SUBTITLE_TRACKS_CLEARED\n  ) => void;\n  [Events.SUBTITLE_TRACK_SWITCH]: (\n    event: Events.SUBTITLE_TRACK_SWITCH,\n    data: SubtitleTrackSwitchData\n  ) => void;\n  [Events.SUBTITLE_TRACK_LOADING]: (\n    event: Events.SUBTITLE_TRACK_LOADING,\n    data: TrackLoadingData\n  ) => void;\n  [Events.SUBTITLE_TRACK_LOADED]: (\n    event: Events.SUBTITLE_TRACK_LOADED,\n    data: SubtitleTrackLoadedData\n  ) => void;\n  [Events.SUBTITLE_FRAG_PROCESSED]: (\n    event: Events.SUBTITLE_FRAG_PROCESSED,\n    data: SubtitleFragProcessedData\n  ) => void;\n  [Events.CUES_PARSED]: (\n    event: Events.CUES_PARSED,\n    data: CuesParsedData\n  ) => void;\n  [Events.NON_NATIVE_TEXT_TRACKS_FOUND]: (\n    event: Events.NON_NATIVE_TEXT_TRACKS_FOUND,\n    data: NonNativeTextTracksData\n  ) => void;\n  [Events.INIT_PTS_FOUND]: (\n    event: Events.INIT_PTS_FOUND,\n    data: InitPTSFoundData\n  ) => void;\n  [Events.FRAG_LOADING]: (\n    event: Events.FRAG_LOADING,\n    data: FragLoadingData\n  ) => void;\n  // [Events.FRAG_LOAD_PROGRESS]: TodoEventType\n  [Events.FRAG_LOAD_EMERGENCY_ABORTED]: (\n    event: Events.FRAG_LOAD_EMERGENCY_ABORTED,\n    data: FragLoadEmergencyAbortedData\n  ) => void;\n  [Events.FRAG_LOADED]: (\n    event: Events.FRAG_LOADED,\n    data: FragLoadedData\n  ) => void;\n  [Events.FRAG_DECRYPTED]: (\n    event: Events.FRAG_DECRYPTED,\n    data: FragDecryptedData\n  ) => void;\n  [Events.FRAG_PARSING_INIT_SEGMENT]: (\n    event: Events.FRAG_PARSING_INIT_SEGMENT,\n    data: FragParsingInitSegmentData\n  ) => void;\n  [Events.FRAG_PARSING_USERDATA]: (\n    event: Events.FRAG_PARSING_USERDATA,\n    data: FragParsingUserdataData\n  ) => void;\n  [Events.FRAG_PARSING_METADATA]: (\n    event: Events.FRAG_PARSING_METADATA,\n    data: FragParsingMetadataData\n  ) => void;\n  // [Events.FRAG_PARSING_DATA]: TodoEventType\n  [Events.FRAG_PARSED]: (\n    event: Events.FRAG_PARSED,\n    data: FragParsedData\n  ) => void;\n  [Events.FRAG_BUFFERED]: (\n    event: Events.FRAG_BUFFERED,\n    data: FragBufferedData\n  ) => void;\n  [Events.FRAG_CHANGED]: (\n    event: Events.FRAG_CHANGED,\n    data: FragChangedData\n  ) => void;\n  [Events.FPS_DROP]: (event: Events.FPS_DROP, data: FPSDropData) => void;\n  [Events.FPS_DROP_LEVEL_CAPPING]: (\n    event: Events.FPS_DROP_LEVEL_CAPPING,\n    data: FPSDropLevelCappingData\n  ) => void;\n  [Events.ERROR]: (event: Events.ERROR, data: ErrorData) => void;\n  [Events.DESTROYING]: (event: Events.DESTROYING) => void;\n  [Events.KEY_LOADING]: (\n    event: Events.KEY_LOADING,\n    data: KeyLoadingData\n  ) => void;\n  [Events.KEY_LOADED]: (event: Events.KEY_LOADED, data: KeyLoadedData) => void;\n  [Events.LIVE_BACK_BUFFER_REACHED]: (\n    event: Events.LIVE_BACK_BUFFER_REACHED,\n    data: LiveBackBufferData\n  ) => void;\n  [Events.BACK_BUFFER_REACHED]: (\n    event: Events.BACK_BUFFER_REACHED,\n    data: BackBufferData\n  ) => void;\n}\nexport interface HlsEventEmitter {\n  on<E extends keyof HlsListeners, Context = undefined>(\n    event: E,\n    listener: HlsListeners[E],\n    context?: Context\n  ): void;\n  once<E extends keyof HlsListeners, Context = undefined>(\n    event: E,\n    listener: HlsListeners[E],\n    context?: Context\n  ): void;\n\n  removeAllListeners<E extends keyof HlsListeners>(event?: E): void;\n  off<E extends keyof HlsListeners, Context = undefined>(\n    event: E,\n    listener?: HlsListeners[E],\n    context?: Context,\n    once?: boolean\n  ): void;\n\n  listeners<E extends keyof HlsListeners>(event: E): HlsListeners[E][];\n  emit<E extends keyof HlsListeners>(\n    event: E,\n    name: E,\n    eventObject: Parameters<HlsListeners[E]>[1]\n  ): boolean;\n  listenerCount<E extends keyof HlsListeners>(event: E): number;\n}\n","export enum ErrorTypes {\n  // Identifier for a network error (loading error / timeout ...)\n  NETWORK_ERROR = 'networkError',\n  // Identifier for a media Error (video/parsing/mediasource error)\n  MEDIA_ERROR = 'mediaError',\n  // EME (encrypted media extensions) errors\n  KEY_SYSTEM_ERROR = 'keySystemError',\n  // Identifier for a mux Error (demuxing/remuxing)\n  MUX_ERROR = 'muxError',\n  // Identifier for all other errors\n  OTHER_ERROR = 'otherError',\n}\n\nexport enum ErrorDetails {\n  KEY_SYSTEM_NO_KEYS = 'keySystemNoKeys',\n  KEY_SYSTEM_NO_ACCESS = 'keySystemNoAccess',\n  KEY_SYSTEM_NO_SESSION = 'keySystemNoSession',\n  KEY_SYSTEM_NO_CONFIGURED_LICENSE = 'keySystemNoConfiguredLicense',\n  KEY_SYSTEM_LICENSE_REQUEST_FAILED = 'keySystemLicenseRequestFailed',\n  KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = 'keySystemServerCertificateRequestFailed',\n  KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = 'keySystemServerCertificateUpdateFailed',\n  KEY_SYSTEM_SESSION_UPDATE_FAILED = 'keySystemSessionUpdateFailed',\n  KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = 'keySystemStatusOutputRestricted',\n  KEY_SYSTEM_STATUS_INTERNAL_ERROR = 'keySystemStatusInternalError',\n  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_ERROR = 'manifestLoadError',\n  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  MANIFEST_LOAD_TIMEOUT = 'manifestLoadTimeOut',\n  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_PARSING_ERROR = 'manifestParsingError',\n  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}\n  MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifestIncompatibleCodecsError',\n  // Identifier for a level which contains no fragments - data: { url: faulty URL, reason: \"no fragments found in level\", level: index of the bad level }\n  LEVEL_EMPTY_ERROR = 'levelEmptyError',\n  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_ERROR = 'levelLoadError',\n  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  LEVEL_LOAD_TIMEOUT = 'levelLoadTimeOut',\n  // Identifier for a level parse error - data: { url : faulty URL, error: Error, reason: error message }\n  LEVEL_PARSING_ERROR = 'levelParsingError',\n  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}\n  LEVEL_SWITCH_ERROR = 'levelSwitchError',\n  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_ERROR = 'audioTrackLoadError',\n  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  AUDIO_TRACK_LOAD_TIMEOUT = 'audioTrackLoadTimeOut',\n  // Identifier for a subtitle track load error - data: { url : faulty URL, response : { code: error code, text: error text }}\n  SUBTITLE_LOAD_ERROR = 'subtitleTrackLoadError',\n  // Identifier for a subtitle track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}\n  SUBTITLE_TRACK_LOAD_TIMEOUT = 'subtitleTrackLoadTimeOut',\n  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  FRAG_LOAD_ERROR = 'fragLoadError',\n  // Identifier for fragment load timeout error - data: { frag : fragment object}\n  FRAG_LOAD_TIMEOUT = 'fragLoadTimeOut',\n  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }\n  FRAG_DECRYPT_ERROR = 'fragDecryptError',\n  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }\n  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release\n  FRAG_PARSING_ERROR = 'fragParsingError',\n  // Identifier for a fragment or part load skipped because of a GAP tag or attribute\n  FRAG_GAP = 'fragGap',\n  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }\n  REMUX_ALLOC_ERROR = 'remuxAllocError',\n  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}\n  KEY_LOAD_ERROR = 'keyLoadError',\n  // Identifier for decrypt key load timeout error - data: { frag : fragment object}\n  KEY_LOAD_TIMEOUT = 'keyLoadTimeOut',\n  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : { error : exception , mimeType : mimeType }\n  BUFFER_ADD_CODEC_ERROR = 'bufferAddCodecError',\n  // Triggered when source buffer(s) could not be created using level (manifest CODECS attribute), parsed media, or best guess codec(s) - data: { reason : error reason }\n  BUFFER_INCOMPATIBLE_CODECS_ERROR = 'bufferIncompatibleCodecsError',\n  // Identifier for a buffer append error - data: append error description\n  BUFFER_APPEND_ERROR = 'bufferAppendError',\n  // Identifier for a buffer appending error event - data: appending error description\n  BUFFER_APPENDING_ERROR = 'bufferAppendingError',\n  // Identifier for a buffer stalled error event\n  BUFFER_STALLED_ERROR = 'bufferStalledError',\n  // Identifier for a buffer full event\n  BUFFER_FULL_ERROR = 'bufferFullError',\n  // Identifier for a buffer seek over hole event\n  BUFFER_SEEK_OVER_HOLE = 'bufferSeekOverHole',\n  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)\n  BUFFER_NUDGE_ON_STALL = 'bufferNudgeOnStall',\n  // Identifier for an internal exception happening inside hls.js while handling an event\n  INTERNAL_EXCEPTION = 'internalException',\n  // Identifier for an internal call to abort a loader\n  INTERNAL_ABORTED = 'aborted',\n  // Uncategorized error\n  UNKNOWN = 'unknown',\n}\n","export default class AESCrypto {\n  private subtle: SubtleCrypto;\n  private aesIV: Uint8Array;\n\n  constructor(subtle: SubtleCrypto, iv: Uint8Array) {\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n\n  decrypt(data: ArrayBuffer, key: CryptoKey) {\n    return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);\n  }\n}\n","export default class FastAESKey {\n  private subtle: any;\n  private key: ArrayBuffer;\n\n  constructor(subtle, key) {\n    this.subtle = subtle;\n    this.key = key;\n  }\n\n  expandKey() {\n    return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, [\n      'encrypt',\n      'decrypt',\n    ]);\n  }\n}\n","export function sliceUint8(\n  array: Uint8Array,\n  start?: number,\n  end?: number\n): Uint8Array {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice\n    ? array.slice(start, end)\n    : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n","import { sliceUint8 } from '../utils/typed-array';\n\n// PKCS7\nexport function removePadding(array: Uint8Array): Uint8Array {\n  const outputBytes = array.byteLength;\n  const paddingBytes =\n    outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return sliceUint8(array, 0, outputBytes - paddingBytes);\n  }\n  return array;\n}\n\nexport default class AESDecryptor {\n  private rcon: Array<number> = [\n    0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36,\n  ];\n  private subMix: Array<Uint32Array> = [\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n  ];\n  private invSubMix: Array<Uint32Array> = [\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n    new Uint32Array(256),\n  ];\n  private sBox: Uint32Array = new Uint32Array(256);\n  private invSBox: Uint32Array = new Uint32Array(256);\n  private key: Uint32Array = new Uint32Array(0);\n\n  private ksRows: number = 0;\n  private keySize: number = 0;\n  private keySchedule!: Uint32Array;\n  private invKeySchedule!: Uint32Array;\n\n  constructor() {\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n\n    return newArray;\n  }\n\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = (i << 1) ^ 0x11b;\n      }\n    }\n\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n      sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n      subMix0[x] = (t << 24) | (t >>> 8);\n      subMix1[x] = (t << 16) | (t >>> 16);\n      subMix2[x] = (t << 8) | (t >>> 24);\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n      invSubMix0[sx] = (t << 24) | (t >>> 8);\n      invSubMix1[sx] = (t << 16) | (t >>> 16);\n      invSubMix2[sx] = (t << 8) | (t >>> 24);\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n\n  expandKey(keyBuffer: ArrayBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n\n    if (sameKey) {\n      return;\n    }\n\n    this.key = key;\n    const keySize = (this.keySize = key.length);\n\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n\n    const ksRows = (this.ksRows = (keySize + 6 + 1) * 4);\n    let ksRow;\n    let invKsRow;\n\n    const keySchedule = (this.keySchedule = new Uint32Array(ksRows));\n    const invKeySchedule = (this.invKeySchedule = new Uint32Array(ksRows));\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n\n    let prev;\n    let t;\n\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = (t << 8) | (t >>> 24);\n\n        // Sub word\n        t =\n          (sbox[t >>> 24] << 24) |\n          (sbox[(t >>> 16) & 0xff] << 16) |\n          (sbox[(t >>> 8) & 0xff] << 8) |\n          sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[(ksRow / keySize) | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t =\n          (sbox[t >>> 24] << 24) |\n          (sbox[(t >>> 16) & 0xff] << 16) |\n          (sbox[(t >>> 8) & 0xff] << 8) |\n          sbox[t & 0xff];\n      }\n\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] =\n          invSubMix0[sbox[t >>> 24]] ^\n          invSubMix1[sbox[(t >>> 16) & 0xff]] ^\n          invSubMix2[sbox[(t >>> 8) & 0xff]] ^\n          invSubMix3[sbox[t & 0xff]];\n      }\n\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return (\n      (word << 24) |\n      ((word & 0xff00) << 8) |\n      ((word & 0xff0000) >> 8) |\n      (word >>> 24)\n    );\n  }\n\n  decrypt(inputArrayBuffer: ArrayBuffer, offset: number, aesIV: ArrayBuffer) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 =\n          invSubMix0[s0 >>> 24] ^\n          invSubMix1[(s1 >> 16) & 0xff] ^\n          invSubMix2[(s2 >> 8) & 0xff] ^\n          invSubMix3[s3 & 0xff] ^\n          invKeySchedule[ksRow];\n        t1 =\n          invSubMix0[s1 >>> 24] ^\n          invSubMix1[(s2 >> 16) & 0xff] ^\n          invSubMix2[(s3 >> 8) & 0xff] ^\n          invSubMix3[s0 & 0xff] ^\n          invKeySchedule[ksRow + 1];\n        t2 =\n          invSubMix0[s2 >>> 24] ^\n          invSubMix1[(s3 >> 16) & 0xff] ^\n          invSubMix2[(s0 >> 8) & 0xff] ^\n          invSubMix3[s1 & 0xff] ^\n          invKeySchedule[ksRow + 2];\n        t3 =\n          invSubMix0[s3 >>> 24] ^\n          invSubMix1[(s0 >> 16) & 0xff] ^\n          invSubMix2[(s1 >> 8) & 0xff] ^\n          invSubMix3[s2 & 0xff] ^\n          invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 =\n        (invSBOX[s0 >>> 24] << 24) ^\n        (invSBOX[(s1 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s2 >> 8) & 0xff] << 8) ^\n        invSBOX[s3 & 0xff] ^\n        invKeySchedule[ksRow];\n      t1 =\n        (invSBOX[s1 >>> 24] << 24) ^\n        (invSBOX[(s2 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s3 >> 8) & 0xff] << 8) ^\n        invSBOX[s0 & 0xff] ^\n        invKeySchedule[ksRow + 1];\n      t2 =\n        (invSBOX[s2 >>> 24] << 24) ^\n        (invSBOX[(s3 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s0 >> 8) & 0xff] << 8) ^\n        invSBOX[s1 & 0xff] ^\n        invKeySchedule[ksRow + 2];\n      t3 =\n        (invSBOX[s3 >>> 24] << 24) ^\n        (invSBOX[(s0 >> 16) & 0xff] << 16) ^\n        (invSBOX[(s1 >> 8) & 0xff] << 8) ^\n        invSBOX[s2 & 0xff] ^\n        invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n\n      offset = offset + 4;\n    }\n\n    return outputInt32.buffer;\n  }\n}\n","export interface ILogFunction {\n  (message?: any, ...optionalParams: any[]): void;\n}\n\nexport interface ILogger {\n  trace: ILogFunction;\n  debug: ILogFunction;\n  log: ILogFunction;\n  warn: ILogFunction;\n  info: ILogFunction;\n  error: ILogFunction;\n}\n\nconst noop: ILogFunction = function () {};\n\nconst fakeLogger: ILogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop,\n};\n\nlet exportedLogger: ILogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type: string): ILogFunction {\n  const func: ILogFunction = self.console[type];\n  if (func) {\n    return func.bind(self.console, `[${type}] >`);\n  }\n  return noop;\n}\n\nfunction exportLoggerFunctions(\n  debugConfig: boolean | ILogger,\n  ...functions: string[]\n): void {\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type]\n      ? debugConfig[type].bind(debugConfig)\n      : consolePrintFn(type);\n  });\n}\n\nexport function enableLogs(debugConfig: boolean | ILogger, id: string): void {\n  // check that console is available\n  if (\n    (self.console && debugConfig === true) ||\n    typeof debugConfig === 'object'\n  ) {\n    exportLoggerFunctions(\n      debugConfig,\n      // Remove out from list here to hard-disable a log-level\n      // 'trace',\n      'debug',\n      'log',\n      'info',\n      'warn',\n      'error'\n    );\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log(\n        `Debug logs enabled for \"${id}\" in hls.js version ${__VERSION__}`\n      );\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\n\nexport const logger: ILogger = exportedLogger;\n","export const isFiniteNumber =\n  Number.isFinite ||\n  function (value) {\n    return typeof value === 'number' && isFinite(value);\n  };\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n","// see https://tools.ietf.org/html/rfc1808\n\n(function (root) {\n  var URL_REGEX =\n    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n  var URLToolkit = {\n    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n    // E.g\n    // With opts.alwaysNormalize = false (default, spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n    // With opts.alwaysNormalize = true (not spec compliant)\n    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n      opts = opts || {};\n      // remove any remaining space and CRLF\n      baseURL = baseURL.trim();\n      relativeURL = relativeURL.trim();\n      if (!relativeURL) {\n        // 2a) If the embedded URL is entirely empty, it inherits the\n        // entire base URL (i.e., is set equal to the base URL)\n        // and we are done.\n        if (!opts.alwaysNormalize) {\n          return baseURL;\n        }\n        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n        if (!basePartsForNormalise) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        basePartsForNormalise.path = URLToolkit.normalizePath(\n          basePartsForNormalise.path\n        );\n        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n      }\n      var relativeParts = URLToolkit.parseURL(relativeURL);\n      if (!relativeParts) {\n        throw new Error('Error trying to parse relative URL.');\n      }\n      if (relativeParts.scheme) {\n        // 2b) If the embedded URL starts with a scheme name, it is\n        // interpreted as an absolute URL and we are done.\n        if (!opts.alwaysNormalize) {\n          return relativeURL;\n        }\n        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n        return URLToolkit.buildURLFromParts(relativeParts);\n      }\n      var baseParts = URLToolkit.parseURL(baseURL);\n      if (!baseParts) {\n        throw new Error('Error trying to parse base URL.');\n      }\n      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n        baseParts.netLoc = pathParts[1];\n        baseParts.path = pathParts[2];\n      }\n      if (baseParts.netLoc && !baseParts.path) {\n        baseParts.path = '/';\n      }\n      var builtParts = {\n        // 2c) Otherwise, the embedded URL inherits the scheme of\n        // the base URL.\n        scheme: baseParts.scheme,\n        netLoc: relativeParts.netLoc,\n        path: null,\n        params: relativeParts.params,\n        query: relativeParts.query,\n        fragment: relativeParts.fragment,\n      };\n      if (!relativeParts.netLoc) {\n        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n        // (if any) of the base URL.\n        builtParts.netLoc = baseParts.netLoc;\n        // 4) If the embedded URL path is preceded by a slash \"/\", the\n        // path is not relative and we skip to Step 7.\n        if (relativeParts.path[0] !== '/') {\n          if (!relativeParts.path) {\n            // 5) If the embedded URL path is empty (and not preceded by a\n            // slash), then the embedded URL inherits the base URL path\n            builtParts.path = baseParts.path;\n            // 5a) if the embedded URL's <params> is non-empty, we skip to\n            // step 7; otherwise, it inherits the <params> of the base\n            // URL (if any) and\n            if (!relativeParts.params) {\n              builtParts.params = baseParts.params;\n              // 5b) if the embedded URL's <query> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <query> of the base\n              // URL (if any) and we skip to step 7.\n              if (!relativeParts.query) {\n                builtParts.query = baseParts.query;\n              }\n            }\n          } else {\n            // 6) The last segment of the base URL's path (anything\n            // following the rightmost slash \"/\", or the entire path if no\n            // slash is present) is removed and the embedded URL's path is\n            // appended in its place.\n            var baseURLPath = baseParts.path;\n            var newPath =\n              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n              relativeParts.path;\n            builtParts.path = URLToolkit.normalizePath(newPath);\n          }\n        }\n      }\n      if (builtParts.path === null) {\n        builtParts.path = opts.alwaysNormalize\n          ? URLToolkit.normalizePath(relativeParts.path)\n          : relativeParts.path;\n      }\n      return URLToolkit.buildURLFromParts(builtParts);\n    },\n    parseURL: function (url) {\n      var parts = URL_REGEX.exec(url);\n      if (!parts) {\n        return null;\n      }\n      return {\n        scheme: parts[1] || '',\n        netLoc: parts[2] || '',\n        path: parts[3] || '',\n        params: parts[4] || '',\n        query: parts[5] || '',\n        fragment: parts[6] || '',\n      };\n    },\n    normalizePath: function (path) {\n      // The following operations are\n      // then applied, in order, to the new path:\n      // 6a) All occurrences of \"./\", where \".\" is a complete path\n      // segment, are removed.\n      // 6b) If the path ends with \".\" as a complete path segment,\n      // that \".\" is removed.\n      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n      // complete path segment not equal to \"..\", are removed.\n      // Removal of these path segments is performed iteratively,\n      // removing the leftmost matching pattern on each iteration,\n      // until no matching pattern remains.\n      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n      // complete path segment not equal to \"..\", that\n      // \"<segment>/..\" is removed.\n      while (\n        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n      ) {}\n      return path.split('').reverse().join('');\n    },\n    buildURLFromParts: function (parts) {\n      return (\n        parts.scheme +\n        parts.netLoc +\n        parts.path +\n        parts.params +\n        parts.query +\n        parts.fragment\n      );\n    },\n  };\n\n  if (typeof exports === 'object' && typeof module === 'object')\n    module.exports = URLToolkit;\n  else if (typeof define === 'function' && define.amd)\n    define([], function () {\n      return URLToolkit;\n    });\n  else if (typeof exports === 'object') exports['URLToolkit'] = URLToolkit;\n  else root['URLToolkit'] = URLToolkit;\n})(this);\n","type RawFrame = { type: string; size: number; data: Uint8Array };\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\ntype DecodedFrame<T> = { key: string; data: T; info?: any };\nexport type Frame = DecodedFrame<ArrayBuffer | string>;\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nexport const isHeader = (data: Uint8Array, offset: number): boolean => {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (\n      data[offset] === 0x49 &&\n      data[offset + 1] === 0x44 &&\n      data[offset + 2] === 0x33\n    ) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (\n          data[offset + 6] < 0x80 &&\n          data[offset + 7] < 0x80 &&\n          data[offset + 8] < 0x80 &&\n          data[offset + 9] < 0x80\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nexport const isFooter = (data: Uint8Array, offset: number): boolean => {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (\n      data[offset] === 0x33 &&\n      data[offset + 1] === 0x44 &&\n      data[offset + 2] === 0x49\n    ) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (\n          data[offset + 6] < 0x80 &&\n          data[offset + 7] < 0x80 &&\n          data[offset + 8] < 0x80 &&\n          data[offset + 9] < 0x80\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\nexport const getID3Data = (\n  data: Uint8Array,\n  offset: number\n): Uint8Array | undefined => {\n  const front = offset;\n  let length = 0;\n\n  while (isHeader(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n\n    const size = readSize(data, offset + 6);\n    length += size;\n\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n\n    offset += length;\n  }\n\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n\n  return undefined;\n};\n\nconst readSize = (data: Uint8Array, offset: number): number => {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\n\nexport const canParse = (data: Uint8Array, offset: number): boolean => {\n  return (\n    isHeader(data, offset) &&\n    readSize(data, offset + 6) + 10 <= data.length - offset\n  );\n};\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */\nexport const getTimeStamp = (data: Uint8Array): number | undefined => {\n  const frames: Frame[] = getID3Frames(data);\n\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame as DecodedFrame<ArrayBuffer>);\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */\nexport const isTimeStampFrame = (frame: Frame): boolean => {\n  return (\n    frame &&\n    frame.key === 'PRIV' &&\n    frame.info === 'com.apple.streaming.transportStreamTimestamp'\n  );\n};\n\nconst getFrameData = (data: Uint8Array): RawFrame => {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type: string = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size: number = readSize(data, 4);\n\n  // skip frame id, size, and flags\n  const offset = 10;\n\n  return { type, size, data: data.subarray(offset, offset + size) };\n};\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */\nexport const getID3Frames = (id3Data: Uint8Array): Frame[] => {\n  let offset = 0;\n  const frames: Frame[] = [];\n\n  while (isHeader(id3Data, offset)) {\n    const size = readSize(id3Data, offset + 6);\n    // skip past ID3 header\n    offset += 10;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + 8 < end) {\n      const frameData: RawFrame = getFrameData(id3Data.subarray(offset));\n      const frame: Frame | undefined = decodeFrame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n\n      // skip frame header and frame data\n      offset += frameData.size + 10;\n    }\n\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n\n  return frames;\n};\n\nexport const decodeFrame = (frame: RawFrame): Frame | undefined => {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n\n  return decodeTextFrame(frame);\n};\n\nconst decodePrivFrame = (\n  frame: RawFrame\n): DecodedFrame<ArrayBuffer> | undefined => {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n\n  return { key: frame.type, info: owner, data: privateData.buffer };\n};\n\nconst decodeTextFrame = (frame: RawFrame): DecodedFrame<string> | undefined => {\n  if (frame.size < 2) {\n    return undefined;\n  }\n\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n\n    return { key: frame.type, info: description, data: value };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return { key: frame.type, data: text };\n};\n\nconst decodeURLFrame = (frame: RawFrame): DecodedFrame<string> | undefined => {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n\n    let index = 1;\n    const description: string = utf8ArrayToStr(\n      frame.data.subarray(index),\n      true\n    );\n\n    index += description.length + 1;\n    const value: string = utf8ArrayToStr(frame.data.subarray(index));\n\n    return { key: frame.type, info: description, data: value };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url: string = utf8ArrayToStr(frame.data);\n  return { key: frame.type, data: url };\n};\n\nconst readTimeStamp = (\n  timeStampFrame: DecodedFrame<ArrayBuffer>\n): number | undefined => {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp =\n      (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n    return Math.round(timestamp);\n  }\n\n  return undefined;\n};\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nexport const utf8ArrayToStr = (\n  array: Uint8Array,\n  exitOnNull: boolean = false\n): string => {\n  const decoder = getTextDecoder();\n  if (decoder) {\n    const decoded = decoder.decode(array);\n\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode(\n          ((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0)\n        );\n        break;\n      default:\n    }\n  }\n  return out;\n};\n\nexport const testables = {\n  decodeTextFrame: decodeTextFrame,\n};\n\nlet decoder: TextDecoder;\n\nfunction getTextDecoder() {\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n\n  return decoder;\n}\n","import { ElementaryStreamTypes } from '../loader/fragment';\nimport { sliceUint8 } from './typed-array';\nimport { utf8ArrayToStr } from '../demux/id3';\nimport { logger } from '../utils/logger';\nimport Hex from './hex';\nimport type { PassthroughTrack, UserdataSample } from '../types/demuxer';\nimport type { DecryptData } from '../loader/level-key';\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nexport const RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4,\n};\n\nexport function bin2str(data: Uint8Array): string {\n  return String.fromCharCode.apply(null, data);\n}\n\nexport function readUint16(buffer: Uint8Array, offset: number): number {\n  const val = (buffer[offset] << 8) | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\n\nexport function readUint32(buffer: Uint8Array, offset: number): number {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\n\nexport function readSint32(buffer: Uint8Array, offset: number): number {\n  return (\n    (buffer[offset] << 24) |\n    (buffer[offset + 1] << 16) |\n    (buffer[offset + 2] << 8) |\n    buffer[offset + 3]\n  );\n}\n\nexport function writeUint32(buffer: Uint8Array, offset: number, value: number) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = (value >> 16) & 0xff;\n  buffer[offset + 2] = (value >> 8) & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find the data for a box specified by its path\nexport function findBox(data: Uint8Array, path: string[]): Uint8Array[] {\n  const results = [] as Uint8Array[];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n\n  for (let i = 0; i < end; ) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\n\ntype SidxInfo = {\n  earliestPresentationTime: number;\n  timescale: number;\n  version: number;\n  referencesCount: number;\n  references: any[];\n};\n\nexport function parseSegmentIndex(sidx: Uint8Array): SidxInfo | null {\n  const references: any[] = [];\n\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n\n  const timescale = readUint32(sidx, index);\n  index += 4;\n\n  // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n  const earliestPresentationTime = 0;\n  const firstOffset = 0;\n\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n\n  let startByte = sidx.length + firstOffset;\n\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n\n    references.push({\n      referenceSize,\n      subsegmentDuration, // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1,\n      },\n    });\n\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references,\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nexport interface InitDataTrack {\n  timescale: number;\n  id: number;\n  codec: string;\n}\n\ntype HdlrType = ElementaryStreamTypes.AUDIO | ElementaryStreamTypes.VIDEO;\n\nexport interface InitData extends Array<any> {\n  [index: number]:\n    | {\n        timescale: number;\n        type: HdlrType;\n        default?: {\n          duration: number;\n          flags: number;\n        };\n      }\n    | undefined;\n  audio?: InitDataTrack;\n  video?: InitDataTrack;\n  caption?: InitDataTrack;\n}\n\nexport function parseInitSegment(initSegment: Uint8Array): InitData {\n  const result: InitData = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      let index = version === 0 ? 12 : 20;\n      const trackId = readUint32(tkhd, index);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        index = version === 0 ? 12 : 20;\n        const timescale = readUint32(mdhd, index);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type: HdlrType | undefined = {\n            soun: ElementaryStreamTypes.AUDIO as const,\n            vide: ElementaryStreamTypes.VIDEO as const,\n          }[hdlrType];\n          if (type) {\n            // Parse codec details\n            const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            let codec;\n            if (stsd) {\n              codec = bin2str(stsd.subarray(12, 16));\n              // TODO: Parse codec details to be able to build MIME type.\n              // stsd.start += 8;\n              // const codecBox = findBox(stsd, [codec])[0];\n              // if (codecBox) {\n              //   TODO: Codec parsing support for avc1, mp4a, hevc, av01...\n              // }\n            }\n            result[trackId] = { timescale, type };\n            result[type] = { timescale, id: trackId, codec };\n          }\n        }\n      }\n    }\n  }\n\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach((trex) => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20),\n      };\n    }\n  });\n\n  return result;\n}\n\nexport function patchEncyptionData(\n  initSegment: Uint8Array | undefined,\n  decryptdata: DecryptData | null\n): Uint8Array | undefined {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach((trak) => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach((enc) => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach((sinf) => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some((b) => b !== 0)) {\n              logger.log(\n                `[eme] Patching keyId in 'enc${\n                  isAudio ? 'a' : 'v'\n                }>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(\n                  keyId\n                )}`\n              );\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n\n  return initSegment;\n}\n\nexport function parseSinf(sinf: Uint8Array): Uint8Array | null {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  logger.error(`[eme] missing 'schm' box`);\n  return null;\n}\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */\nexport function getStartDTS(\n  initData: InitData,\n  fmp4: Uint8Array\n): number | null {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce(\n    (result: number | null, traf) => {\n      const tfdt = findBox(traf, ['tfdt'])[0];\n      const version = tfdt[0];\n      const start = findBox(traf, ['tfhd']).reduce(\n        (result: number | null, tfhd) => {\n          // get the track id from the tfhd\n          const id = readUint32(tfhd, 4);\n          const track = initData[id];\n          if (track) {\n            let baseTime = readUint32(tfdt, 4);\n            if (version === 1) {\n              // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n              // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n              // https://github.com/video-dev/hls.js/issues/5303\n              if (baseTime === UINT32_MAX) {\n                logger.warn(\n                  `[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`\n                );\n                return result;\n              }\n              baseTime *= UINT32_MAX + 1;\n              baseTime += readUint32(tfdt, 8);\n            }\n            // assume a 90kHz clock if no timescale was specified\n            const scale = track.timescale || 90e3;\n            // convert base time to seconds\n            const startTime = baseTime / scale;\n            if (\n              isFinite(startTime) &&\n              (result === null || startTime < result)\n            ) {\n              return startTime;\n            }\n          }\n          return result;\n        },\n        null\n      );\n      if (\n        start !== null &&\n        isFinite(start) &&\n        (result === null || start < result)\n      ) {\n        return start;\n      }\n      return result;\n    },\n    null\n  );\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nexport function getDuration(data: Uint8Array, initData: InitData) {\n  let rawDuration = 0;\n  let videoDuration = 0;\n  let audioDuration = 0;\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | trackDefault?.flags!;\n    let sampleDuration: number | undefined = trackDefault?.duration;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    // assume a 90kHz clock if no timescale was specified\n    const timescale = track.timescale || 90e3;\n    const truns = findBox(traf, ['trun']);\n    for (let j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n      if (!rawDuration && sampleDuration) {\n        const sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n      if (track.type === ElementaryStreamTypes.VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === ElementaryStreamTypes.AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxDuration = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx?.references) {\n        sidxDuration += sidx.references.reduce(\n          (dur, ref) => dur + ref.info.duration || 0,\n          0\n        );\n      }\n    }\n\n    return sidxDuration;\n  }\n  if (videoDuration) {\n    return videoDuration;\n  }\n  return audioDuration;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\nexport function computeRawDurationFromSamples(trun): number {\n  const flags = readUint32(trun, 0);\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n  let offset = 8;\n  // data-offset-present flag\n  if (flags & 0x000001) {\n    offset += 4;\n  }\n  // first-sample-flags-present flag\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n\n  let duration = 0;\n  const sampleCount = readUint32(trun, 4);\n  for (let i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      const sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    }\n    // sample-size-present flag\n    if (flags & 0x000200) {\n      offset += 4;\n    }\n    // sample-flags-present flag\n    if (flags & 0x000400) {\n      offset += 4;\n    }\n    // sample-composition-time-offsets-present flag\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n  return duration;\n}\n\nexport function offsetStartDTS(\n  initData: InitData,\n  fmp4: Uint8Array,\n  timeOffset: number\n) {\n  findBox(fmp4, ['moof', 'traf']).forEach((traf) => {\n    findBox(traf, ['tfhd']).forEach((tfhd) => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (!track) {\n        return;\n      }\n      // assume a 90kHz clock if no timescale was specified\n      const timescale = track.timescale || 90e3;\n      // get the base media decode time from the tfdt\n      findBox(traf, ['tfdt']).forEach((tfdt) => {\n        const version = tfdt[0];\n        let baseMediaDecodeTime = readUint32(tfdt, 4);\n\n        if (version === 0) {\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          writeUint32(tfdt, 4, baseMediaDecodeTime);\n        } else {\n          baseMediaDecodeTime *= Math.pow(2, 32);\n          baseMediaDecodeTime += readUint32(tfdt, 8);\n          baseMediaDecodeTime -= timeOffset * timescale;\n          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n          const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n          const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n          writeUint32(tfdt, 4, upper);\n          writeUint32(tfdt, 8, lower);\n        }\n      });\n    });\n  });\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nexport function segmentValidRange(data: Uint8Array): SegmentedRange {\n  const segmentedRange: SegmentedRange = {\n    valid: null,\n    remainder: null,\n  };\n\n  const moofs = findBox(data, ['moof']);\n  if (!moofs) {\n    return segmentedRange;\n  } else if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n  return segmentedRange;\n}\n\nexport interface SegmentedRange {\n  valid: Uint8Array | null;\n  remainder: Uint8Array | null;\n}\n\nexport function appendUint8Array(\n  data1: Uint8Array,\n  data2: Uint8Array\n): Uint8Array {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n\n  return temp;\n}\n\nexport interface IEmsgParsingData {\n  schemeIdUri: string;\n  value: string;\n  timeScale: number;\n  presentationTimeDelta?: number;\n  presentationTime?: number;\n  eventDuration: number;\n  id: number;\n  payload: Uint8Array;\n}\n\nexport function parseSamples(\n  timeOffset: number,\n  track: PassthroughTrack\n): UserdataSample[] {\n  const seiSamples = [] as UserdataSample[];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map((moof) => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map((traf) => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map((tfdt) => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n\n      return findBox(traf, ['tfhd']).map((tfhd) => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n\n          findBox(traf, ['trun']).map((trun) => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n\n            let sampleOffset = dataOffset + moofOffset;\n\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(\n                      sampleOffset,\n                      sampleOffset + naluSize\n                    );\n                    parseSEIMessageFromNALu(\n                      data,\n                      isHEVCFlavor ? 2 : 1,\n                      timeOffset + compositionOffset / timescale,\n                      seiSamples\n                    );\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\n\nfunction isHEVC(codec: string) {\n  if (!codec) {\n    return false;\n  }\n  const delimit = codec.indexOf('.');\n  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return (\n    baseCodec === 'hvc1' ||\n    baseCodec === 'hev1' ||\n    // Dolby Vision\n    baseCodec === 'dvh1' ||\n    baseCodec === 'dvhe'\n  );\n}\n\nfunction isSEIMessage(isHEVCFlavor: boolean, naluHeader: number) {\n  if (isHEVCFlavor) {\n    const naluType = (naluHeader >> 1) & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\n\nexport function parseSEIMessageFromNALu(\n  unescapedData: Uint8Array,\n  headerSize: number,\n  pts: number,\n  samples: UserdataSample[]\n) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let endOfCaptions = false;\n  let b = 0;\n\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n\n    const leftOver = data.length - seiPtr;\n\n    if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {\n      endOfCaptions = true;\n\n      const countryCode = data[seiPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, seiPtr);\n        seiPtr += 2;\n\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, seiPtr);\n          seiPtr += 4;\n\n          if (userStructure === 0x47413934) {\n            const userDataType = data[seiPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[seiPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[seiPtr++];\n                }\n              }\n\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray,\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5 && payloadSize < leftOver) {\n      endOfCaptions = true;\n\n      if (payloadSize > 16) {\n        const uuidStrArray: Array<string> = [];\n        for (let i = 0; i < 16; i++) {\n          const b = data[seiPtr++].toString(16);\n          uuidStrArray.push(b.length == 1 ? '0' + b : b);\n\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[seiPtr++];\n        }\n\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes,\n        });\n      }\n    } else if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      break;\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nexport function discardEPB(data: Uint8Array): Uint8Array {\n  const length = data.byteLength;\n  const EPBPositions = [] as Array<number>;\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\n\nexport function parseEmsg(data: Uint8Array): IEmsgParsingData {\n  const version = data[0];\n  let schemeIdUri: string = '';\n  let value: string = '';\n  let timeScale: number = 0;\n  let presentationTimeDelta: number = 0;\n  let presentationTime: number = 0;\n  let eventDuration: number = 0;\n  let id: number = 0;\n  let offset: number = 0;\n\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!Number.isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn(\n        'Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box'\n      );\n    }\n\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload,\n  };\n}\n\nexport function mp4Box(type: ArrayLike<number>, ...payload: Uint8Array[]) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = (size >> 24) & 0xff;\n  result[1] = (size >> 16) & 0xff;\n  result[2] = (size >> 8) & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\n\nexport function mp4pssh(\n  systemId: Uint8Array,\n  keyids: Array<Uint8Array> | null,\n  data: Uint8Array\n) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  if (keyids) {\n    version = 1;\n    kids = new Uint8Array(keyids.length * 16);\n    for (let ix = 0; ix < keyids.length; ix++) {\n      const k = keyids[ix]; // uint8array\n      if (k.byteLength !== 16) {\n        throw new RangeError('Invalid key');\n      }\n      kids.set(k, ix * 16);\n    }\n  } else {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids!.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids!.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box(\n    [112, 115, 115, 104],\n    new Uint8Array([\n      version,\n      0x00,\n      0x00,\n      0x00, // Flags\n    ]),\n    systemId, // 16 bytes\n    kidCount,\n    kids,\n    dataSize,\n    data || new Uint8Array()\n  );\n}\n\nexport function parsePssh(initData: ArrayBuffer) {\n  if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\n    return null;\n  }\n  const result = {\n    version: 0,\n    systemId: '',\n    kids: null as null | Uint8Array[],\n    data: null as null | Uint8Array,\n  };\n  const view = new DataView(initData);\n  const boxSize = view.getUint32(0);\n  if (initData.byteLength !== boxSize && boxSize > 44) {\n    return null;\n  }\n  const type = view.getUint32(4);\n  if (type !== 0x70737368) {\n    return null;\n  }\n  result.version = view.getUint32(8) >>> 24;\n  if (result.version > 1) {\n    return null;\n  }\n  result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));\n  const dataSizeOrKidCount = view.getUint32(28);\n  if (result.version === 0) {\n    if (boxSize - 32 < dataSizeOrKidCount) {\n      return null;\n    }\n    result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\n  } else if (result.version === 1) {\n    result.kids = [];\n    for (let i = 0; i < dataSizeOrKidCount; i++) {\n      result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\n    }\n  }\n  return result;\n}\n","import AESCrypto from './aes-crypto';\nimport FastAESKey from './fast-aes-key';\nimport AESDecryptor, { removePadding } from './aes-decryptor';\nimport { logger } from '../utils/logger';\nimport { appendUint8Array } from '../utils/mp4-tools';\nimport { sliceUint8 } from '../utils/typed-array';\nimport type { HlsConfig } from '../config';\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nexport default class Decrypter {\n  private logEnabled: boolean = true;\n  private removePKCS7Padding: boolean;\n  private subtle: SubtleCrypto | null = null;\n  private softwareDecrypter: AESDecryptor | null = null;\n  private key: ArrayBuffer | null = null;\n  private fastAesKey: FastAESKey | null = null;\n  private remainderData: Uint8Array | null = null;\n  private currentIV: ArrayBuffer | null = null;\n  private currentResult: ArrayBuffer | null = null;\n  private useSoftware: boolean;\n\n  constructor(config: HlsConfig, { removePKCS7Padding = true } = {}) {\n    this.useSoftware = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle =\n            browserCrypto.subtle ||\n            ((browserCrypto as any).webkitSubtle as SubtleCrypto);\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    if (this.subtle === null) {\n      this.useSoftware = true;\n    }\n  }\n\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n\n  public isSync() {\n    return this.useSoftware;\n  }\n\n  public flush(): Uint8Array | null {\n    const { currentResult, remainderData } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n\n  public reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n\n  public decrypt(\n    data: Uint8Array | ArrayBuffer,\n    key: ArrayBuffer,\n    iv: ArrayBuffer\n  ): Promise<ArrayBuffer> {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        this.softwareDecrypt(new Uint8Array(data), key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  public softwareDecrypt(\n    data: Uint8Array,\n    key: ArrayBuffer,\n    iv: ArrayBuffer\n  ): ArrayBuffer | null {\n    const { currentIV, currentResult, remainderData } = this;\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n\n    if (currentIV) {\n      iv = currentIV;\n    }\n\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n\n    const result = currentResult;\n\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = sliceUint8(currentChunk, -16).buffer;\n\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n\n  public webCryptoDecrypt(\n    data: Uint8Array,\n    key: ArrayBuffer,\n    iv: ArrayBuffer\n  ): Promise<ArrayBuffer> {\n    const subtle = this.subtle;\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new FastAESKey(subtle, key);\n    }\n    return this.fastAesKey\n      .expandKey()\n      .then((aesKey) => {\n        // decrypt using web crypto\n        if (!subtle) {\n          return Promise.reject(new Error('web crypto not initialized'));\n        }\n        this.logOnce('WebCrypto AES decrypt');\n        const crypto = new AESCrypto(subtle, new Uint8Array(iv));\n        return crypto.decrypt(data.buffer, aesKey);\n      })\n      .catch((err) => {\n        logger.warn(\n          `[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`\n        );\n\n        return this.onWebCryptoError(data, key, iv);\n      });\n  }\n\n  private onWebCryptoError(data, key, iv): ArrayBuffer | never {\n    this.useSoftware = true;\n    this.logEnabled = true;\n    this.softwareDecrypt(data, key, iv);\n    const decryptResult = this.flush();\n    if (decryptResult) {\n      return decryptResult.buffer;\n    }\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n  }\n\n  private getValidChunk(data: Uint8Array): Uint8Array {\n    let currentChunk = data;\n    const splitPoint = data.length - (data.length % CHUNK_SIZE);\n    if (splitPoint !== data.length) {\n      currentChunk = sliceUint8(data, 0, splitPoint);\n      this.remainderData = sliceUint8(data, splitPoint);\n    }\n    return currentChunk;\n  }\n\n  private logOnce(msg: string) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n","import type { RationalTimestamp } from '../utils/timescale-conversion';\n\nexport interface Demuxer {\n  demux(\n    data: Uint8Array,\n    timeOffset: number,\n    isSampleAes?: boolean,\n    flush?: boolean\n  ): DemuxerResult;\n  demuxSampleAes(\n    data: Uint8Array,\n    keyData: KeyData,\n    timeOffset: number\n  ): Promise<DemuxerResult>;\n  flush(timeOffset?: number): DemuxerResult | Promise<DemuxerResult>;\n  destroy(): void;\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number\n  );\n  resetTimeStamp(defaultInitPTS?: RationalTimestamp | null): void;\n  resetContiguity(): void;\n}\n\nexport interface DemuxerResult {\n  audioTrack: DemuxedAudioTrack;\n  videoTrack: DemuxedVideoTrack;\n  id3Track: DemuxedMetadataTrack;\n  textTrack: DemuxedUserdataTrack;\n}\n\nexport interface DemuxedTrack {\n  type: string;\n  id: number;\n  pid: number;\n  inputTimeScale: number;\n  sequenceNumber: number;\n  samples:\n    | AudioSample[]\n    | AvcSample[]\n    | MetadataSample[]\n    | UserdataSample[]\n    | Uint8Array;\n  timescale?: number;\n  container?: string;\n  dropped: number;\n  duration?: number;\n  pesData?: ElementaryStreamData | null;\n  codec?: string;\n}\n\nexport interface PassthroughTrack extends DemuxedTrack {\n  sampleDuration: number;\n  samples: Uint8Array;\n  timescale: number;\n  duration: number;\n  codec: string;\n}\nexport interface DemuxedAudioTrack extends DemuxedTrack {\n  config?: number[];\n  samplerate?: number;\n  segmentCodec?: string;\n  channelCount?: number;\n  manifestCodec?: string;\n  samples: AudioSample[];\n}\n\nexport interface DemuxedVideoTrack extends DemuxedTrack {\n  width?: number;\n  height?: number;\n  pixelRatio?: [number, number];\n  audFound?: boolean;\n  pps?: Uint8Array[];\n  sps?: Uint8Array[];\n  naluState?: number;\n  samples: AvcSample[] | Uint8Array;\n}\n\nexport interface DemuxedAvcTrack extends DemuxedVideoTrack {\n  samples: AvcSample[];\n}\n\nexport interface DemuxedMetadataTrack extends DemuxedTrack {\n  samples: MetadataSample[];\n}\n\nexport interface DemuxedUserdataTrack extends DemuxedTrack {\n  samples: UserdataSample[];\n}\n\nexport const enum MetadataSchema {\n  audioId3 = 'org.id3',\n  dateRange = 'com.apple.quicktime.HLS',\n  emsg = 'https://aomedia.org/emsg/ID3',\n}\nexport interface MetadataSample {\n  pts: number;\n  dts: number;\n  duration: number;\n  len?: number;\n  data: Uint8Array;\n  type: MetadataSchema;\n}\n\nexport interface UserdataSample {\n  pts: number;\n  bytes?: Uint8Array;\n  type?: number;\n  payloadType?: number;\n  uuid?: string;\n  userData?: string;\n  userDataBytes?: Uint8Array;\n}\n\nexport interface AvcSample {\n  dts: number;\n  pts: number;\n  key: boolean;\n  frame: boolean;\n  units: AvcSampleUnit[];\n  debug: string;\n  length: number;\n}\n\nexport interface AvcSampleUnit {\n  data: Uint8Array;\n  type: number;\n}\n\nexport type AudioSample = {\n  unit: Uint8Array;\n  pts: number;\n};\n\nexport type AudioFrame = {\n  sample: AudioSample;\n  length: number;\n  missing: number;\n};\n\nexport interface ElementaryStreamData {\n  data: Uint8Array[];\n  size: number;\n}\n\nexport interface KeyData {\n  method: string;\n  key: Uint8Array;\n  iv: Uint8Array;\n}\n","import type { DemuxedTrack } from '../types/demuxer';\n\nexport function dummyTrack(type = '', inputTimeScale = 90000): DemuxedTrack {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0,\n  };\n}\n","import * as ID3 from '../demux/id3';\nimport {\n  DemuxerResult,\n  Demuxer,\n  DemuxedAudioTrack,\n  AudioFrame,\n  DemuxedMetadataTrack,\n  DemuxedVideoTrack,\n  DemuxedUserdataTrack,\n  KeyData,\n  MetadataSchema,\n} from '../types/demuxer';\nimport { dummyTrack } from './dummy-demuxed-track';\nimport { appendUint8Array } from '../utils/mp4-tools';\nimport { sliceUint8 } from '../utils/typed-array';\nimport { RationalTimestamp } from '../utils/timescale-conversion';\n\nclass BaseAudioDemuxer implements Demuxer {\n  protected _audioTrack!: DemuxedAudioTrack;\n  protected _id3Track!: DemuxedMetadataTrack;\n  protected frameIndex: number = 0;\n  protected cachedData: Uint8Array | null = null;\n  protected basePTS: number | null = null;\n  protected initPTS: RationalTimestamp | null = null;\n  protected lastPTS: number | null = null;\n\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number\n  ) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n    };\n  }\n\n  resetTimeStamp(deaultTimestamp: RationalTimestamp | null) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n\n  resetContiguity(): void {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n\n  canParse(data: Uint8Array, offset: number): boolean {\n    return false;\n  }\n\n  appendFrame(\n    track: DemuxedAudioTrack,\n    data: Uint8Array,\n    offset: number\n  ): AudioFrame | void {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data: Uint8Array, timeOffset: number): DemuxerResult {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n\n    let id3Data: Uint8Array | undefined = ID3.getID3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? ID3.getTimeStamp(id3Data) : undefined;\n    const length = data.length;\n\n    if (\n      this.basePTS === null ||\n      (this.frameIndex === 0 && Number.isFinite(timestamp))\n    ) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY,\n      });\n    }\n\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (ID3.canParse(data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = ID3.getID3Data(data, offset)!;\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY,\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = sliceUint8(data, lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack() as DemuxedVideoTrack,\n      id3Track,\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\n    };\n  }\n\n  demuxSampleAes(\n    data: Uint8Array,\n    keyData: KeyData,\n    timeOffset: number\n  ): Promise<DemuxerResult> {\n    return Promise.reject(\n      new Error(`[${this}] This demuxer does not support Sample-AES decryption`)\n    );\n  }\n\n  flush(timeOffset: number): DemuxerResult {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack() as DemuxedVideoTrack,\n      id3Track: this._id3Track,\n      textTrack: dummyTrack() as DemuxedUserdataTrack,\n    };\n  }\n\n  destroy() {}\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nexport const initPTSFn = (\n  timestamp: number | undefined,\n  timeOffset: number,\n  initPTS: RationalTimestamp | null\n): number => {\n  if (Number.isFinite(timestamp as number)) {\n    return timestamp! * 90;\n  }\n  const init90kHz = initPTS\n    ? (initPTS.baseTime * 90000) / initPTS.timescale\n    : 0;\n  return timeOffset * 90000 + init90kHz;\n};\nexport default BaseAudioDemuxer;\n","/**\n *  MPEG parser helper\n */\nimport { DemuxedAudioTrack } from '../types/demuxer';\n\nlet chromeVersion: number | null = null;\n\nconst BitratesMap = [\n  32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56,\n  64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80,\n  96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144,\n  160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144,\n  160,\n];\n\nconst SamplingRateMap = [\n  44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000,\n];\n\nconst SamplesCoefficients = [\n  // MPEG 2.5\n  [\n    0, // Reserved\n    72, // Layer3\n    144, // Layer2\n    12, // Layer1\n  ],\n  // Reserved\n  [\n    0, // Reserved\n    0, // Layer3\n    0, // Layer2\n    0, // Layer1\n  ],\n  // MPEG 2\n  [\n    0, // Reserved\n    72, // Layer3\n    144, // Layer2\n    12, // Layer1\n  ],\n  // MPEG 1\n  [\n    0, // Reserved\n    144, // Layer3\n    144, // Layer2\n    12, // Layer1\n  ],\n];\n\nconst BytesInSlot = [\n  0, // Reserved\n  1, // Layer3\n  1, // Layer2\n  4, // Layer1\n];\n\nexport function appendFrame(\n  track: DemuxedAudioTrack,\n  data: Uint8Array,\n  offset: number,\n  pts: number,\n  frameIndex: number\n) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = (header.samplesPerFrame * 90000) / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp,\n    };\n\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n\n    return { sample, length: header.frameLength, missing: 0 };\n  }\n}\n\nexport function parseHeader(data: Uint8Array, offset: number) {\n  const mpegVersion = (data[offset + 1] >> 3) & 3;\n  const mpegLayer = (data[offset + 1] >> 1) & 3;\n  const bitRateIndex = (data[offset + 2] >> 4) & 15;\n  const sampleRateIndex = (data[offset + 2] >> 2) & 3;\n  if (\n    mpegVersion !== 1 &&\n    bitRateIndex !== 0 &&\n    bitRateIndex !== 15 &&\n    sampleRateIndex !== 3\n  ) {\n    const paddingBit = (data[offset + 2] >> 1) & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates =\n      mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate =\n      BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates =\n      mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate =\n      SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength =\n      Math.floor((sampleCoefficient * bitRate) / sampleRate + paddingBit) *\n      bytesInSlot;\n\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion && chromeVersion <= 87;\n\n    if (\n      needChromeFix &&\n      mpegLayer === 2 &&\n      bitRate >= 224000 &&\n      channelMode === 0\n    ) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n\n    return { sampleRate, channelCount, frameLength, samplesPerFrame };\n  }\n}\n\nexport function isHeaderPattern(data: Uint8Array, offset: number): boolean {\n  return (\n    data[offset] === 0xff &&\n    (data[offset + 1] & 0xe0) === 0xe0 &&\n    (data[offset + 1] & 0x06) !== 0x00\n  );\n}\n\nexport function isHeader(data: Uint8Array, offset: number): boolean {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\n\nexport function canParse(data: Uint8Array, offset: number): boolean {\n  const headerSize = 4;\n\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\n\nexport function probe(data: Uint8Array, offset: number): boolean {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header?.frameLength) {\n      frameLength = header.frameLength;\n    }\n\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n","/**\n * MP3 demuxer\n */\nimport BaseAudioDemuxer from './base-audio-demuxer';\nimport * as ID3 from '../demux/id3';\nimport { logger } from '../utils/logger';\nimport * as MpegAudio from './mpegaudio';\n\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(\n    initSegment: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number\n  ) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0,\n    };\n  }\n\n  static probe(data): boolean {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = ID3.getID3Data(data, 0) || [];\n    let offset = id3Data.length;\n\n    for (let length = data.length; offset < length; offset++) {\n      if (MpegAudio.probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n\n  canParse(data, offset) {\n    return MpegAudio.canParse(data, offset);\n  }\n\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return MpegAudio.appendFrame(\n      track,\n      data,\n      offset,\n      this.basePTS,\n      this.frameIndex\n    );\n  }\n}\n\nexport default MP3Demuxer;\n","/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(\n    codec?: string,\n    channelCount?: number\n  ): Uint8Array | undefined {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80,\n          ]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x8e,\n          ]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38,\n          ]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38,\n          ]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\n            0x00, 0x20, 0x08, 0xe0,\n          ]);\n        }\n\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e,\n          ]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e,\n          ]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e,\n          ]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\nexport default AAC;\n","/**\n * Generate MP4 Box\n */\n\ntype HdlrTypes = {\n  video: Uint8Array;\n  audio: Uint8Array;\n};\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\n\nclass MP4 {\n  public static types: Record<string, number[]>;\n  private static HDLR_TYPES: HdlrTypes;\n  private static STTS: Uint8Array;\n  private static STSC: Uint8Array;\n  private static STCO: Uint8Array;\n  private static STSZ: Uint8Array;\n  private static VMHD: Uint8Array;\n  private static SMHD: Uint8Array;\n  private static STSD: Uint8Array;\n  private static FTYP: Uint8Array;\n  private static DINF: Uint8Array;\n\n  static init() {\n    MP4.types = {\n      avc1: [], // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: [],\n    };\n\n    let i: string;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [\n          i.charCodeAt(0),\n          i.charCodeAt(1),\n          i.charCodeAt(2),\n          i.charCodeAt(3),\n        ];\n      }\n    }\n\n    const videoHdlr = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x76,\n      0x69,\n      0x64,\n      0x65, // handler_type: 'vide'\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x56,\n      0x69,\n      0x64,\n      0x65,\n      0x6f,\n      0x48,\n      0x61,\n      0x6e,\n      0x64,\n      0x6c,\n      0x65,\n      0x72,\n      0x00, // name: 'VideoHandler'\n    ]);\n\n    const audioHdlr = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x73,\n      0x6f,\n      0x75,\n      0x6e, // handler_type: 'soun'\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x53,\n      0x6f,\n      0x75,\n      0x6e,\n      0x64,\n      0x48,\n      0x61,\n      0x6e,\n      0x64,\n      0x6c,\n      0x65,\n      0x72,\n      0x00, // name: 'SoundHandler'\n    ]);\n\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr,\n    };\n\n    const dref = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x01, // entry_count\n      0x00,\n      0x00,\n      0x00,\n      0x0c, // entry_size\n      0x75,\n      0x72,\n      0x6c,\n      0x20, // 'url' type\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x01, // entry_flags\n    ]);\n\n    const stco = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // entry_count\n    ]);\n\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n\n    MP4.STSZ = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // sample_size\n      0x00,\n      0x00,\n      0x00,\n      0x00, // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x01, // flags\n      0x00,\n      0x00, // graphicsmode\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00, // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00, // balance\n      0x00,\n      0x00, // reserved\n    ]);\n\n    MP4.STSD = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x01,\n    ]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n\n    MP4.FTYP = MP4.box(\n      MP4.types.ftyp,\n      majorBrand,\n      minorVersion,\n      majorBrand,\n      avc1Brand\n    );\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n\n  static box(type, ...payload: Uint8Array[]) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    const result = new Uint8Array(size);\n    result[0] = (size >> 24) & 0xff;\n    result[1] = (size >> 16) & 0xff;\n    result[2] = (size >> 8) & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(\n      MP4.types.mdhd,\n      new Uint8Array([\n        0x01, // version 1\n        0x00,\n        0x00,\n        0x00, // flags\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x02, // creation_time\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x03, // modification_time\n        (timescale >> 24) & 0xff,\n        (timescale >> 16) & 0xff,\n        (timescale >> 8) & 0xff,\n        timescale & 0xff, // timescale\n        upperWordDuration >> 24,\n        (upperWordDuration >> 16) & 0xff,\n        (upperWordDuration >> 8) & 0xff,\n        upperWordDuration & 0xff,\n        lowerWordDuration >> 24,\n        (lowerWordDuration >> 16) & 0xff,\n        (lowerWordDuration >> 8) & 0xff,\n        lowerWordDuration & 0xff,\n        0x55,\n        0xc4, // 'und' language (undetermined)\n        0x00,\n        0x00,\n      ])\n    );\n  }\n\n  static mdia(track) {\n    return MP4.box(\n      MP4.types.mdia,\n      MP4.mdhd(track.timescale, track.duration),\n      MP4.hdlr(track.type),\n      MP4.minf(track)\n    );\n  }\n\n  static mfhd(sequenceNumber) {\n    return MP4.box(\n      MP4.types.mfhd,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00,\n        0x00, // flags\n        sequenceNumber >> 24,\n        (sequenceNumber >> 16) & 0xff,\n        (sequenceNumber >> 8) & 0xff,\n        sequenceNumber & 0xff, // sequence_number\n      ])\n    );\n  }\n\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(\n        MP4.types.minf,\n        MP4.box(MP4.types.smhd, MP4.SMHD),\n        MP4.DINF,\n        MP4.stbl(track)\n      );\n    } else {\n      return MP4.box(\n        MP4.types.minf,\n        MP4.box(MP4.types.vmhd, MP4.VMHD),\n        MP4.DINF,\n        MP4.stbl(track)\n      );\n    }\n  }\n\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(\n      MP4.types.moof,\n      MP4.mfhd(sn),\n      MP4.traf(track, baseMediaDecodeTime)\n    );\n  }\n\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes: Uint8Array[] = [];\n\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n\n    return MP4.box.apply(\n      null,\n      [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)]\n        .concat(boxes)\n        .concat(MP4.mvex(tracks))\n    );\n  }\n\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes: Uint8Array[] = [];\n\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([\n      0x01, // version 1\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x02, // creation_time\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x03, // modification_time\n      (timescale >> 24) & 0xff,\n      (timescale >> 16) & 0xff,\n      (timescale >> 8) & 0xff,\n      timescale & 0xff, // timescale\n      upperWordDuration >> 24,\n      (upperWordDuration >> 16) & 0xff,\n      (upperWordDuration >> 8) & 0xff,\n      upperWordDuration & 0xff,\n      lowerWordDuration >> 24,\n      (lowerWordDuration >> 16) & 0xff,\n      (lowerWordDuration >> 8) & 0xff,\n      lowerWordDuration & 0xff,\n      0x00,\n      0x01,\n      0x00,\n      0x00, // 1.0 rate\n      0x01,\n      0x00, // 1.0 volume\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x01,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x01,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x40,\n      0x00,\n      0x00,\n      0x00, // transformation: unity matrix\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0xff,\n      0xff,\n      0xff,\n      0xff, // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] =\n        (flags.dependsOn << 4) |\n        (flags.isDependedOn << 2) |\n        flags.hasRedundancy;\n    }\n\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n\n  static stbl(track) {\n    return MP4.box(\n      MP4.types.stbl,\n      MP4.stsd(track),\n      MP4.box(MP4.types.stts, MP4.STTS),\n      MP4.box(MP4.types.stsc, MP4.STSC),\n      MP4.box(MP4.types.stsz, MP4.STSZ),\n      MP4.box(MP4.types.stco, MP4.STCO)\n    );\n  }\n\n  static avc1(track) {\n    let sps: number[] = [];\n    let pps: number[] = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push((len >>> 8) & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push((len >>> 8) & 0xff);\n      pps.push(len & 0xff);\n\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n\n    const avcc = MP4.box(\n      MP4.types.avcC,\n      new Uint8Array(\n        [\n          0x01, // version\n          sps[3], // profile\n          sps[4], // profile compat\n          sps[5], // level\n          0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n          0xe0 | track.sps.length, // 3bit reserved (111) + numOfSequenceParameterSets\n        ]\n          .concat(sps)\n          .concat([\n            track.pps.length, // numOfPictureParameterSets\n          ])\n          .concat(pps)\n      )\n    ); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n\n    return MP4.box(\n      MP4.types.avc1,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00, // pre_defined\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // pre_defined\n        (width >> 8) & 0xff,\n        width & 0xff, // width\n        (height >> 8) & 0xff,\n        height & 0xff, // height\n        0x00,\n        0x48,\n        0x00,\n        0x00, // horizresolution\n        0x00,\n        0x48,\n        0x00,\n        0x00, // vertresolution\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // frame_count\n        0x12,\n        0x64,\n        0x61,\n        0x69,\n        0x6c, // dailymotion/hls.js\n        0x79,\n        0x6d,\n        0x6f,\n        0x74,\n        0x69,\n        0x6f,\n        0x6e,\n        0x2f,\n        0x68,\n        0x6c,\n        0x73,\n        0x2e,\n        0x6a,\n        0x73,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // compressorname\n        0x00,\n        0x18, // depth = 24\n        0x11,\n        0x11,\n      ]), // pre_defined = -1\n      avcc,\n      MP4.box(\n        MP4.types.btrt,\n        new Uint8Array([\n          0x00,\n          0x1c,\n          0x9c,\n          0x80, // bufferSizeDB\n          0x00,\n          0x2d,\n          0xc6,\n          0xc0, // maxBitrate\n          0x00,\n          0x2d,\n          0xc6,\n          0xc0,\n        ])\n      ), // avgBitrate\n      MP4.box(\n        MP4.types.pasp,\n        new Uint8Array([\n          hSpacing >> 24, // hSpacing\n          (hSpacing >> 16) & 0xff,\n          (hSpacing >> 8) & 0xff,\n          hSpacing & 0xff,\n          vSpacing >> 24, // vSpacing\n          (vSpacing >> 16) & 0xff,\n          (vSpacing >> 8) & 0xff,\n          vSpacing & 0xff,\n        ])\n      )\n    );\n  }\n\n  static esds(track) {\n    const configlen = track.config.length;\n    return new Uint8Array(\n      [\n        0x00, // version 0\n        0x00,\n        0x00,\n        0x00, // flags\n\n        0x03, // descriptor_type\n        0x17 + configlen, // length\n        0x00,\n        0x01, // es_id\n        0x00, // stream_priority\n\n        0x04, // descriptor_type\n        0x0f + configlen, // length\n        0x40, // codec : mpeg4_audio\n        0x15, // stream_type\n        0x00,\n        0x00,\n        0x00, // buffer_size\n        0x00,\n        0x00,\n        0x00,\n        0x00, // maxBitrate\n        0x00,\n        0x00,\n        0x00,\n        0x00, // avgBitrate\n\n        0x05, // descriptor_type\n      ]\n        .concat([configlen])\n        .concat(track.config)\n        .concat([0x06, 0x01, 0x02])\n    ); // GASpecificConfig)); // length + audio config descriptor\n  }\n\n  static mp4a(track) {\n    const samplerate = track.samplerate;\n    return MP4.box(\n      MP4.types.mp4a,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        track.channelCount, // channelcount\n        0x00,\n        0x10, // sampleSize:16bits\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved2\n        (samplerate >> 8) & 0xff,\n        samplerate & 0xff, //\n        0x00,\n        0x00,\n      ]),\n      MP4.box(MP4.types.esds, MP4.esds(track))\n    );\n  }\n\n  static mp3(track) {\n    const samplerate = track.samplerate;\n    return MP4.box(\n      MP4.types['.mp3'],\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        track.channelCount, // channelcount\n        0x00,\n        0x10, // sampleSize:16bits\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved2\n        (samplerate >> 8) & 0xff,\n        samplerate & 0xff, //\n        0x00,\n        0x00,\n      ])\n    );\n  }\n\n  static stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  }\n\n  static tkhd(track) {\n    const id = track.id;\n    const duration = track.duration * track.timescale;\n    const width = track.width;\n    const height = track.height;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(\n      MP4.types.tkhd,\n      new Uint8Array([\n        0x01, // version 1\n        0x00,\n        0x00,\n        0x07, // flags\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x02, // creation_time\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x03, // modification_time\n        (id >> 24) & 0xff,\n        (id >> 16) & 0xff,\n        (id >> 8) & 0xff,\n        id & 0xff, // track_ID\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        upperWordDuration >> 24,\n        (upperWordDuration >> 16) & 0xff,\n        (upperWordDuration >> 8) & 0xff,\n        upperWordDuration & 0xff,\n        lowerWordDuration >> 24,\n        (lowerWordDuration >> 16) & 0xff,\n        (lowerWordDuration >> 8) & 0xff,\n        lowerWordDuration & 0xff,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00, // layer\n        0x00,\n        0x00, // alternate_group\n        0x00,\n        0x00, // non-audio track volume\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x01,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x40,\n        0x00,\n        0x00,\n        0x00, // transformation: unity matrix\n        (width >> 8) & 0xff,\n        width & 0xff,\n        0x00,\n        0x00, // width\n        (height >> 8) & 0xff,\n        height & 0xff,\n        0x00,\n        0x00, // height\n      ])\n    );\n  }\n\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(\n      baseMediaDecodeTime / (UINT32_MAX + 1)\n    );\n    const lowerWordBaseMediaDecodeTime = Math.floor(\n      baseMediaDecodeTime % (UINT32_MAX + 1)\n    );\n    return MP4.box(\n      MP4.types.traf,\n      MP4.box(\n        MP4.types.tfhd,\n        new Uint8Array([\n          0x00, // version 0\n          0x00,\n          0x00,\n          0x00, // flags\n          id >> 24,\n          (id >> 16) & 0xff,\n          (id >> 8) & 0xff,\n          id & 0xff, // track_ID\n        ])\n      ),\n      MP4.box(\n        MP4.types.tfdt,\n        new Uint8Array([\n          0x01, // version 1\n          0x00,\n          0x00,\n          0x00, // flags\n          upperWordBaseMediaDecodeTime >> 24,\n          (upperWordBaseMediaDecodeTime >> 16) & 0xff,\n          (upperWordBaseMediaDecodeTime >> 8) & 0xff,\n          upperWordBaseMediaDecodeTime & 0xff,\n          lowerWordBaseMediaDecodeTime >> 24,\n          (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n          (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n          lowerWordBaseMediaDecodeTime & 0xff,\n        ])\n      ),\n      MP4.trun(\n        track,\n        sampleDependencyTable.length +\n          16 + // tfhd\n          20 + // tfdt\n          8 + // traf header\n          16 + // mfhd\n          8 + // moof header\n          8\n      ), // mdat header\n      sampleDependencyTable\n    );\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(\n      MP4.types.trex,\n      new Uint8Array([\n        0x00, // version 0\n        0x00,\n        0x00,\n        0x00, // flags\n        id >> 24,\n        (id >> 16) & 0xff,\n        (id >> 8) & 0xff,\n        id & 0xff, // track_ID\n        0x00,\n        0x00,\n        0x00,\n        0x01, // default_sample_description_index\n        0x00,\n        0x00,\n        0x00,\n        0x00, // default_sample_duration\n        0x00,\n        0x00,\n        0x00,\n        0x00, // default_sample_size\n        0x00,\n        0x01,\n        0x00,\n        0x01, // default_sample_flags\n      ])\n    );\n  }\n\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set(\n      [\n        track.type === 'video' ? 0x01 : 0x00, // version 1 for video with signed-int sample_composition_time_offset\n        0x00,\n        0x0f,\n        0x01, // flags\n        (len >>> 24) & 0xff,\n        (len >>> 16) & 0xff,\n        (len >>> 8) & 0xff,\n        len & 0xff, // sample_count\n        (offset >>> 24) & 0xff,\n        (offset >>> 16) & 0xff,\n        (offset >>> 8) & 0xff,\n        offset & 0xff, // data_offset\n      ],\n      0\n    );\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set(\n        [\n          (duration >>> 24) & 0xff,\n          (duration >>> 16) & 0xff,\n          (duration >>> 8) & 0xff,\n          duration & 0xff, // sample_duration\n          (size >>> 24) & 0xff,\n          (size >>> 16) & 0xff,\n          (size >>> 8) & 0xff,\n          size & 0xff, // sample_size\n          (flags.isLeading << 2) | flags.dependsOn,\n          (flags.isDependedOn << 6) |\n            (flags.hasRedundancy << 4) |\n            (flags.paddingValue << 1) |\n            flags.isNonSync,\n          flags.degradPrio & (0xf0 << 8),\n          flags.degradPrio & 0x0f, // sample_flags\n          (cts >>> 24) & 0xff,\n          (cts >>> 16) & 0xff,\n          (cts >>> 8) & 0xff,\n          cts & 0xff, // sample_composition_time_offset\n        ],\n        12 + 16 * i\n      );\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n\n    const movie = MP4.moov(tracks);\n    const result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);\n    result.set(MP4.FTYP);\n    result.set(movie, MP4.FTYP.byteLength);\n    return result;\n  }\n}\n\nexport default MP4;\n","import type { LoaderConfig } from '../config';\nimport type { Fragment } from '../loader/fragment';\nimport type { Part } from '../loader/fragment';\nimport type { KeyLoaderInfo } from '../loader/key-loader';\nimport type { LevelDetails } from '../loader/level-details';\nimport type { HlsUrlParameters } from './level';\n\nexport interface LoaderContext {\n  // target URL\n  url: string;\n  // loader response type (arraybuffer or default response type for playlist)\n  responseType: string;\n  // headers\n  headers?: Record<string, string>;\n  // start byte range offset\n  rangeStart?: number;\n  // end byte range offset\n  rangeEnd?: number;\n  // true if onProgress should report partial chunk of loaded content\n  progressData?: boolean;\n}\n\nexport interface FragmentLoaderContext extends LoaderContext {\n  frag: Fragment;\n  part: Part | null;\n  resetIV?: boolean;\n}\n\nexport interface KeyLoaderContext extends LoaderContext {\n  keyInfo: KeyLoaderInfo;\n  frag: Fragment;\n}\n\nexport interface LoaderConfiguration {\n  // LoaderConfig policy that overrides required settings\n  loadPolicy: LoaderConfig;\n  /**\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry maxNumRetry\n   */\n  // Max number of load retries\n  maxRetry: number;\n  /**\n   * @deprecated use LoaderConfig maxTimeToFirstByteMs and maxLoadTimeMs\n   */\n  // Timeout after which `onTimeOut` callback will be triggered\n  //  when loading has not finished after that delay\n  timeout: number;\n  /**\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry retryDelayMs\n   */\n  // Delay between an I/O error and following connection retry (ms).\n  // This to avoid spamming the server\n  retryDelay: number;\n  /**\n   * @deprecated use LoaderConfig timeoutRetry and errorRetry maxRetryDelayMs\n   */\n  // max connection retry delay (ms)\n  maxRetryDelay: number;\n  // When streaming progressively, this is the minimum chunk size required to emit a PROGRESS event\n  highWaterMark?: number;\n}\n\nexport interface LoaderResponse {\n  url: string;\n  data?: string | ArrayBuffer | Object;\n  // Errors can include HTTP status code and error message\n  // Successful responses should include status code 200\n  code?: number;\n  text?: string;\n}\n\nexport interface LoaderStats {\n  aborted: boolean;\n  loaded: number;\n  retry: number;\n  total: number;\n  chunkCount: number;\n  bwEstimate: number;\n  loading: HlsProgressivePerformanceTiming;\n  parsing: HlsPerformanceTiming;\n  buffering: HlsProgressivePerformanceTiming;\n}\n\nexport interface HlsPerformanceTiming {\n  start: number;\n  end: number;\n}\n\nexport interface HlsChunkPerformanceTiming extends HlsPerformanceTiming {\n  executeStart: number;\n  executeEnd: number;\n}\n\nexport interface HlsProgressivePerformanceTiming extends HlsPerformanceTiming {\n  first: number;\n}\n\nexport type LoaderOnSuccess<T extends LoaderContext> = (\n  response: LoaderResponse,\n  stats: LoaderStats,\n  context: T,\n  networkDetails: any\n) => void;\n\nexport type LoaderOnProgress<T extends LoaderContext> = (\n  stats: LoaderStats,\n  context: T,\n  data: string | ArrayBuffer,\n  networkDetails: any\n) => void;\n\nexport type LoaderOnError<T extends LoaderContext> = (\n  error: {\n    // error status code\n    code: number;\n    // error description\n    text: string;\n  },\n  context: T,\n  networkDetails: any,\n  stats: LoaderStats\n) => void;\n\nexport type LoaderOnTimeout<T extends LoaderContext> = (\n  stats: LoaderStats,\n  context: T,\n  networkDetails: any\n) => void;\n\nexport type LoaderOnAbort<T extends LoaderContext> = (\n  stats: LoaderStats,\n  context: T,\n  networkDetails: any\n) => void;\n\nexport interface LoaderCallbacks<T extends LoaderContext> {\n  onSuccess: LoaderOnSuccess<T>;\n  onError: LoaderOnError<T>;\n  onTimeout: LoaderOnTimeout<T>;\n  onAbort?: LoaderOnAbort<T>;\n  onProgress?: LoaderOnProgress<T>;\n}\n\nexport interface Loader<T extends LoaderContext> {\n  destroy(): void;\n  abort(): void;\n  load(\n    context: LoaderContext,\n    config: LoaderConfiguration,\n    callbacks: LoaderCallbacks<T>\n  ): void;\n  /**\n   * `getCacheAge()` is called by hls.js to get the duration that a given object\n   * has been sitting in a cache proxy when playing live.  If implemented,\n   * this should return a value in seconds.\n   *\n   * For HTTP based loaders, this should return the contents of the \"age\" header.\n   *\n   * @returns time object being lodaded\n   */\n  getCacheAge?: () => number | null;\n  getResponseHeader?: (name: string) => string | null;\n  context: T;\n  stats: LoaderStats;\n}\n\nexport const enum PlaylistContextType {\n  MANIFEST = 'manifest',\n  LEVEL = 'level',\n  AUDIO_TRACK = 'audioTrack',\n  SUBTITLE_TRACK = 'subtitleTrack',\n}\n\nexport const enum PlaylistLevelType {\n  MAIN = 'main',\n  AUDIO = 'audio',\n  SUBTITLE = 'subtitle',\n}\n\nexport interface PlaylistLoaderContext extends LoaderContext {\n  type: PlaylistContextType;\n  // the level index to load\n  level: number | null;\n  // level or track id from LevelLoadingData / TrackLoadingData\n  id: number | null;\n  // track group id\n  groupId?: string;\n  // internal representation of a parsed m3u8 level playlist\n  levelDetails?: LevelDetails;\n  // Blocking playlist request delivery directives (or null id none were added to playlist url\n  deliveryDirectives: HlsUrlParameters | null;\n}\n","const MPEG_TS_CLOCK_FREQ_HZ = 90000;\n\nexport type RationalTimestamp = {\n  baseTime: number; // ticks\n  timescale: number; // ticks per second\n};\n\nexport function toTimescaleFromBase(\n  baseTime: number,\n  destScale: number,\n  srcBase: number = 1,\n  round: boolean = false\n): number {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\n\nexport function toTimescaleFromScale(\n  baseTime: number,\n  destScale: number,\n  srcScale: number = 1,\n  round: boolean = false\n): number {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\n\nexport function toMsFromMpegTsClock(\n  baseTime: number,\n  round: boolean = false\n): number {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\n\nexport function toMpegTsClockFromTimescale(\n  baseTime: number,\n  srcScale: number = 1\n): number {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n","import AAC from './aac-helper';\nimport MP4 from './mp4-generator';\nimport type { HlsEventEmitter } from '../events';\nimport { Events } from '../events';\nimport { ErrorTypes, ErrorDetails } from '../errors';\nimport { logger } from '../utils/logger';\nimport {\n  InitSegmentData,\n  Remuxer,\n  RemuxerResult,\n  RemuxedMetadata,\n  RemuxedTrack,\n  RemuxedUserdata,\n} from '../types/remuxer';\nimport { PlaylistLevelType } from '../types/loader';\nimport {\n  RationalTimestamp,\n  toMsFromMpegTsClock,\n} from '../utils/timescale-conversion';\nimport type {\n  AudioSample,\n  AvcSample,\n  DemuxedAudioTrack,\n  DemuxedAvcTrack,\n  DemuxedMetadataTrack,\n  DemuxedUserdataTrack,\n} from '../types/demuxer';\nimport type { TrackSet } from '../types/track';\nimport type { SourceBufferName } from '../types/buffer';\nimport type { Fragment } from '../loader/fragment';\nimport type { HlsConfig } from '../config';\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\n\nlet chromeVersion: number | null = null;\nlet safariWebkitVersion: number | null = null;\n\nexport default class MP4Remuxer implements Remuxer {\n  private observer: HlsEventEmitter;\n  private config: HlsConfig;\n  private typeSupported: any;\n  private ISGenerated: boolean = false;\n  private _initPTS: RationalTimestamp | null = null;\n  private _initDTS: RationalTimestamp | null = null;\n  private nextAvcDts: number | null = null;\n  private nextAudioPts: number | null = null;\n  private videoSampleDuration: number | null = null;\n  private isAudioContiguous: boolean = false;\n  private isVideoContiguous: boolean = false;\n\n  constructor(\n    observer: HlsEventEmitter,\n    config: HlsConfig,\n    typeSupported,\n    vendor = ''\n  ) {\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n\n  destroy() {}\n\n  resetTimeStamp(defaultTimeStamp: RationalTimestamp | null) {\n    logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n\n  resetNextTimestamp() {\n    logger.log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n\n  resetInitSegment() {\n    logger.log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n  }\n\n  getVideoStartPts(videoSamples) {\n    let rolloverDetected = false;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      const delta = sample.pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n    if (rolloverDetected) {\n      logger.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n\n  remux(\n    audioTrack: DemuxedAudioTrack,\n    videoTrack: DemuxedAvcTrack,\n    id3Track: DemuxedMetadataTrack,\n    textTrack: DemuxedUserdataTrack,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    flush: boolean,\n    playlistType: PlaylistLevelType\n  ): RemuxerResult {\n    let video: RemuxedTrack | undefined;\n    let audio: RemuxedTrack | undefined;\n    let initSegment: InitSegmentData | undefined;\n    let text: RemuxedUserdata | undefined;\n    let id3: RemuxedMetadata | undefined;\n    let independent: boolean | undefined;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = (flush && length > 0) || length > 1;\n    const canRemuxAvc =\n      ((!hasAudio || enoughAudioSamples) &&\n        (!hasVideo || enoughVideoSamples)) ||\n      this.ISGenerated ||\n      flush;\n\n    if (canRemuxAvc) {\n      if (!this.ISGenerated) {\n        initSegment = this.generateIS(\n          audioTrack,\n          videoTrack,\n          timeOffset,\n          accurateTimeOffset\n        );\n      }\n\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            logger.warn(\n              `[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`\n            );\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset +=\n              (videoTrack.samples[0].pts - startPTS) /\n              videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            logger.warn(\n              `[mp4-remuxer]: No keyframe found out of ${length} video samples`\n            );\n            independent = false;\n          }\n        }\n      }\n\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta =\n            normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            logger.warn(\n              '[mp4-remuxer]: regenerate InitSegment as audio detected'\n            );\n            initSegment = this.generateIS(\n              audioTrack,\n              videoTrack,\n              timeOffset,\n              accurateTimeOffset\n            );\n          }\n          audio = this.remuxAudio(\n            audioTrack,\n            audioTimeOffset,\n            this.isAudioContiguous,\n            accurateTimeOffset,\n            hasVideo ||\n              enoughVideoSamples ||\n              playlistType === PlaylistLevelType.AUDIO\n              ? videoTimeOffset\n              : undefined\n          );\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              logger.warn(\n                '[mp4-remuxer]: regenerate InitSegment as video detected'\n              );\n              initSegment = this.generateIS(\n                audioTrack,\n                videoTrack,\n                timeOffset,\n                accurateTimeOffset\n              );\n            }\n            video = this.remuxVideo(\n              videoTrack,\n              videoTimeOffset,\n              isVideoContiguous,\n              audioTrackLength\n            );\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(\n            videoTrack,\n            videoTimeOffset,\n            isVideoContiguous,\n            0\n          );\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(\n          id3Track,\n          timeOffset,\n          this._initPTS,\n          this._initDTS\n        );\n      }\n\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(\n          textTrack,\n          timeOffset,\n          this._initPTS\n        );\n      }\n    }\n\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3,\n    };\n  }\n\n  generateIS(\n    audioTrack: DemuxedAudioTrack,\n    videoTrack: DemuxedAvcTrack,\n    timeOffset: number,\n    accurateTimeOffset: boolean\n  ): InitSegmentData | undefined {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks: TrackSet = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS: number | undefined;\n    let initDTS: number | undefined;\n    let timescale: number | undefined;\n\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment:\n          audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg\n            ? new Uint8Array(0)\n            : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount,\n        },\n      };\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS =\n            audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height,\n        },\n      };\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(\n            initDTS as number,\n            normalizePts(videoSamples[0].dts, startPTS) - startOffset\n          );\n          initPTS = Math.min(initPTS as number, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS as number,\n          timescale: timescale as number,\n        };\n        this._initDTS = {\n          baseTime: initDTS as number,\n          timescale: timescale as number,\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n\n      return {\n        tracks,\n        initPTS,\n        timescale,\n      };\n    }\n  }\n\n  remuxVideo(\n    track: DemuxedAvcTrack,\n    timeOffset: number,\n    contiguous: boolean,\n    audioTrackLength: number\n  ): RemuxedTrack | undefined {\n    const timeScale: number = track.inputTimeScale;\n    const inputSamples: Array<AvcSample> = track.samples;\n    const outputSamples: Array<Mp4Sample> = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS as RationalTimestamp;\n    let nextAvcDts = this.nextAvcDts;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS: number = Number.POSITIVE_INFINITY;\n    let maxPTS: number = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextAvcDts === null) {\n      const pts = timeOffset * timeScale;\n      const cts =\n        inputSamples[0].pts -\n        normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      // if not contiguous, let's use target timeOffset\n      nextAvcDts = pts - cts;\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const initTime = (initPTS.baseTime * timeScale) / initPTS.timescale;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration\n      ? Math.round(inputDuration / (nbSamples - 1))\n      : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextAvcDts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          logger.warn(\n            `AVC: ${toMsFromMpegTsClock(\n              delta,\n              true\n            )} ms (${delta}dts) hole between fragments detected, filling it`\n          );\n        } else {\n          logger.warn(\n            `AVC: ${toMsFromMpegTsClock(\n              -delta,\n              true\n            )} ms (${delta}dts) overlapping between fragments detected`\n          );\n        }\n        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {\n          firstDTS = nextAvcDts;\n          const firstPTS = inputSamples[0].pts - delta;\n          inputSamples[0].dts = firstDTS;\n          inputSamples[0].pts = firstPTS;\n          logger.log(\n            `Video: First PTS/DTS adjusted: ${toMsFromMpegTsClock(\n              firstPTS,\n              true\n            )}/${toMsFromMpegTsClock(\n              firstDTS,\n              true\n            )}, delta: ${toMsFromMpegTsClock(delta, true)} ms`\n          );\n        }\n      }\n    }\n\n    firstDTS = Math.max(0, firstDTS);\n\n    let nbNalu = 0;\n    let naluLen = 0;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      sample.dts = Math.max(sample.dts, firstDTS);\n\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`,\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const avcSample = inputSamples[i];\n      const avcSampleUnits = avcSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = avcSampleUnits.length; j < nbUnits; j++) {\n        const unit = avcSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - avcSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - avcSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration =\n          i > 0\n            ? avcSample.dts - inputSamples[i - 1].dts\n            : averageSampleDuration;\n        ptsDelta =\n          i > 0\n            ? avcSample.pts - inputSamples[i - 1].pts\n            : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd =\n            (audioTrackLength\n              ? minPTS + audioTrackLength * timeScale\n              : this.nextAudioPts) - avcSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            logger.log(\n              `[mp4-remuxer]: It is approximately ${\n                deltaToFrameEnd / 90\n              } ms to the next segment; using duration ${\n                mp4SampleDuration / 90\n              } ms for the last video frame.`\n            );\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n\n      outputSamples.push(\n        new Mp4Sample(\n          avcSample.key,\n          mp4SampleDuration,\n          mp4SampleLength,\n          compositionTimeOffset\n        )\n      );\n    }\n\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (\n          maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta &&\n          averageSampleDuration / maxDtsDelta < 0.025 &&\n          outputSamples[0].cts === 0\n        ) {\n          logger.warn(\n            'Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.'\n          );\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i\n                ? outputSamples[i - 1].duration\n                : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration =\n      stretchedLastFrame || !mp4SampleDuration\n        ? averageSampleDuration\n        : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(\n      track.sequenceNumber++,\n      firstDTS,\n      Object.assign({}, track, {\n        samples: outputSamples,\n      })\n    );\n    const type: SourceBufferName = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: (nextAvcDts as number) / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped,\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n\n  remuxAudio(\n    track: DemuxedAudioTrack,\n    timeOffset: number,\n    contiguous: boolean,\n    accurateTimeOffset: boolean,\n    videoTimeOffset?: number\n  ): RemuxedTrack | undefined {\n    const inputTimeScale: number = track.inputTimeScale;\n    const mp4timeScale: number = track.samplerate\n      ? track.samplerate\n      : inputTimeScale;\n    const scaleFactor: number = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration: number =\n      track.segmentCodec === 'aac'\n        ? AAC_SAMPLES_PER_FRAME\n        : MPEG_AUDIO_SAMPLE_PER_FRAME;\n    const inputSampleDuration: number = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS as RationalTimestamp;\n    const rawMPEG: boolean =\n      track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples: Array<Mp4Sample> = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n\n    let inputSamples: Array<AudioSample> = track.samples;\n    let offset: number = rawMPEG ? 0 : 8;\n    let nextAudioPts: number = this.nextAudioPts || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const timeOffsetMpegTS = timeOffset * inputTimeScale;\n    const initTime = (initPTS.baseTime * inputTimeScale) / initPTS.timescale;\n    this.isAudioContiguous = contiguous =\n      contiguous ||\n      ((inputSamples.length &&\n        nextAudioPts > 0 &&\n        ((accurateTimeOffset &&\n          Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000) ||\n          Math.abs(\n            normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) -\n              nextAudioPts\n          ) <\n            20 * inputSampleDuration)) as boolean);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n    });\n\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter((sample) => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs((1000 * delta) / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (\n          delta <= -maxAudioFramesDrift * inputSampleDuration &&\n          alignedWithVideo\n        ) {\n          if (i === 0) {\n            logger.warn(\n              `Audio frame @ ${(pts / inputTimeScale).toFixed(\n                3\n              )}s overlaps nextAudioPts by ${Math.round(\n                (1000 * delta) / inputTimeScale\n              )} ms.`\n            );\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (\n          delta >= maxAudioFramesDrift * inputSampleDuration &&\n          duration < MAX_SILENT_FRAME_DURATION &&\n          alignedWithVideo\n        ) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n          logger.warn(\n            `[mp4-remuxer]: Injecting ${missing} audio frame @ ${(\n              nextPts / inputTimeScale\n            ).toFixed(3)}s due to ${Math.round(\n              (1000 * delta) / inputTimeScale\n            )} ms gap.`\n          );\n          for (let j = 0; j < missing; j++) {\n            const newStamp = Math.max(nextPts as number, 0);\n            let fillFrame = AAC.getSilentFrame(\n              track.manifestCodec || track.codec,\n              track.channelCount\n            );\n            if (!fillFrame) {\n              logger.log(\n                '[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.'\n              );\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp,\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS: number | null = null;\n    let lastPTS: number | null = null;\n    let mdat: any;\n    let mdatSize: number = 0;\n    let sampleLength: number = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, nbSamples = inputSamples.length; j < nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioPts;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`,\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts =\n      lastPTS! + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG\n      ? new Uint8Array(0)\n      : MP4.moof(\n          track.sequenceNumber++,\n          firstPTS! / scaleFactor,\n          Object.assign({}, track, { samples: outputSamples })\n        );\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = firstPTS! / inputTimeScale;\n    const end = nextAudioPts / inputTimeScale;\n    const type: SourceBufferName = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples,\n    };\n\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n\n  remuxEmptyAudio(\n    track: DemuxedAudioTrack,\n    timeOffset: number,\n    contiguous: boolean,\n    videoData: Fragment\n  ): RemuxedTrack | undefined {\n    const inputTimeScale: number = track.inputTimeScale;\n    const mp4timeScale: number = track.samplerate\n      ? track.samplerate\n      : inputTimeScale;\n    const scaleFactor: number = inputTimeScale / mp4timeScale;\n    const nextAudioPts: number | null = this.nextAudioPts;\n    // sync with video's timestamp\n    const initDTS = this._initDTS as RationalTimestamp;\n    const init90kHz = (initDTS.baseTime * 90000) / initDTS.timescale;\n    const startDTS: number =\n      (nextAudioPts !== null\n        ? nextAudioPts\n        : videoData.startDTS * inputTimeScale) + init90kHz;\n    const endDTS: number = videoData.endDTS * inputTimeScale + init90kHz;\n    // one sample's duration value\n    const frameDuration: number = scaleFactor * AAC_SAMPLES_PER_FRAME;\n    // samples count of this segment's duration\n    const nbSamples: number = Math.ceil((endDTS - startDTS) / frameDuration);\n    // silent frame\n    const silentFrame: Uint8Array | undefined = AAC.getSilentFrame(\n      track.manifestCodec || track.codec,\n      track.channelCount\n    );\n\n    logger.warn('[mp4-remuxer]: remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      logger.trace(\n        '[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec'\n      );\n      return;\n    }\n\n    const samples: Array<any> = [];\n    for (let i = 0; i < nbSamples; i++) {\n      const stamp = startDTS + i * frameDuration;\n      samples.push({ unit: silentFrame, pts: stamp, dts: stamp });\n    }\n    track.samples = samples;\n\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  }\n}\n\nexport function normalizePts(value: number, reference: number | null): number {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n\n  return value;\n}\n\nfunction findKeyframeIndex(samples: Array<AvcSample>): number {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function flushTextTrackMetadataCueSamples(\n  track: DemuxedMetadataTrack,\n  timeOffset: number,\n  initPTS: RationalTimestamp,\n  initDTS: RationalTimestamp\n): RemuxedMetadata | undefined {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts =\n      normalizePts(\n        sample.pts - (initPTS.baseTime * inputTimeScale) / initPTS.timescale,\n        timeOffset * inputTimeScale\n      ) / inputTimeScale;\n    sample.dts =\n      normalizePts(\n        sample.dts - (initDTS.baseTime * inputTimeScale) / initDTS.timescale,\n        timeOffset * inputTimeScale\n      ) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples,\n  };\n}\n\nexport function flushTextTrackUserdataCueSamples(\n  track: DemuxedUserdataTrack,\n  timeOffset: number,\n  initPTS: RationalTimestamp\n): RemuxedUserdata | undefined {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts =\n      normalizePts(\n        sample.pts - (initPTS.baseTime * inputTimeScale) / initPTS.timescale,\n        timeOffset * inputTimeScale\n      ) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples,\n  };\n}\n\nclass Mp4Sample {\n  public size: number;\n  public duration: number;\n  public cts: number;\n  public flags: Mp4SampleFlags;\n\n  constructor(\n    isKeyframe: boolean,\n    duration: number,\n    size: number,\n    cts: number\n  ) {\n    this.duration = duration;\n    this.size = size;\n    this.cts = cts;\n    this.flags = new Mp4SampleFlags(isKeyframe);\n  }\n}\n\nclass Mp4SampleFlags {\n  public isLeading: 0 = 0;\n  public isDependedOn: 0 = 0;\n  public hasRedundancy: 0 = 0;\n  public degradPrio: 0 = 0;\n  public dependsOn: 1 | 2 = 1;\n  public isNonSync: 0 | 1 = 1;\n\n  constructor(isKeyframe) {\n    this.dependsOn = isKeyframe ? 2 : 1;\n    this.isNonSync = isKeyframe ? 0 : 1;\n  }\n}\n","import type { HlsEventEmitter } from '../events';\nimport { Events } from '../events';\nimport { ErrorTypes, ErrorDetails } from '../errors';\nimport Decrypter from '../crypt/decrypter';\nimport AACDemuxer from '../demux/aacdemuxer';\nimport MP4Demuxer from '../demux/mp4demuxer';\nimport TSDemuxer, { TypeSupported } from '../demux/tsdemuxer';\nimport MP3Demuxer from '../demux/mp3demuxer';\nimport MP4Remuxer from '../remux/mp4-remuxer';\nimport PassThroughRemuxer from '../remux/passthrough-remuxer';\nimport { logger } from '../utils/logger';\nimport type { Demuxer, DemuxerResult, KeyData } from '../types/demuxer';\nimport type { Remuxer } from '../types/remuxer';\nimport type { TransmuxerResult, ChunkMetadata } from '../types/transmuxer';\nimport type { HlsConfig } from '../config';\nimport type { DecryptData } from '../loader/level-key';\nimport type { PlaylistLevelType } from '../types/loader';\nimport type { RationalTimestamp } from '../utils/timescale-conversion';\n\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  logger.debug('Unable to use Performance API on this environment');\n  now = typeof self !== 'undefined' && self.Date.now;\n}\n\ntype MuxConfig =\n  | { demux: typeof MP4Demuxer; remux: typeof PassThroughRemuxer }\n  | { demux: typeof TSDemuxer; remux: typeof MP4Remuxer }\n  | { demux: typeof AACDemuxer; remux: typeof MP4Remuxer }\n  | { demux: typeof MP3Demuxer; remux: typeof MP4Remuxer };\n\nconst muxConfig: MuxConfig[] = [\n  // { demux: MP4Demuxer, remux: PassThroughRemuxer },\n  // { demux: TSDemuxer, remux: MP4Remuxer },\n  // { demux: AACDemuxer, remux: MP4Remuxer },\n  { demux: MP3Demuxer, remux: MP4Remuxer },\n];\n\nexport default class Transmuxer {\n  public async: boolean = false;\n  private observer: HlsEventEmitter;\n  private typeSupported: TypeSupported;\n  private config: HlsConfig;\n  private vendor: string;\n  private id: PlaylistLevelType;\n  private demuxer?: Demuxer;\n  private remuxer?: Remuxer;\n  private decrypter?: Decrypter;\n  private probe!: Function;\n  private decryptionPromise: Promise<TransmuxerResult> | null = null;\n  private transmuxConfig!: TransmuxConfig;\n  private currentTransmuxState!: TransmuxState;\n\n  constructor(\n    observer: HlsEventEmitter,\n    typeSupported: TypeSupported,\n    config: HlsConfig,\n    vendor: string,\n    id: PlaylistLevelType\n  ) {\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n\n  configure(transmuxConfig: TransmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n\n  push(\n    data: ArrayBuffer,\n    decryptdata: DecryptData | null,\n    chunkMeta: ChunkMetadata,\n    state?: TransmuxState\n  ): TransmuxerResult | Promise<TransmuxerResult> {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n\n    let uintData: Uint8Array = new Uint8Array(data);\n    const { currentTransmuxState, transmuxConfig } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange,\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData,\n    } = transmuxConfig;\n\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && keyData.method === 'AES-128') {\n      const decrypter = this.getDecrypter();\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(\n          uintData,\n          keyData.key.buffer,\n          keyData.iv.buffer\n        );\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          decryptedData = decrypter.flush();\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter\n          .webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer)\n          .then((decryptedData): TransmuxerResult => {\n            // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n            // the decrypted data has been transmuxed\n            const result = this.push(\n              decryptedData,\n              null,\n              chunkMeta\n            ) as TransmuxerResult;\n            this.decryptionPromise = null;\n            return result;\n          });\n        return this.decryptionPromise!;\n      }\n    }\n\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message,\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(\n        initSegmentData,\n        audioCodec,\n        videoCodec,\n        duration,\n        decryptdata\n      );\n    }\n\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n\n    const result = this.transmux(\n      uintData,\n      keyData,\n      timeOffset,\n      accurateTimeOffset,\n      chunkMeta\n    );\n    const currentState = this.currentTransmuxState;\n\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(\n    chunkMeta: ChunkMetadata\n  ): TransmuxerResult[] | Promise<TransmuxerResult[]> {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n\n    const { decrypter, currentTransmuxState, decryptionPromise } = this;\n\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n\n    const transmuxResults: TransmuxerResult[] = [];\n    const { timeOffset } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(\n          this.push(decryptedData, null, chunkMeta) as TransmuxerResult\n        );\n      }\n    }\n\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then((demuxResult) => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  }\n\n  private flushRemux(\n    transmuxResults: TransmuxerResult[],\n    demuxResult: DemuxerResult,\n    chunkMeta: ChunkMetadata\n  ) {\n    const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n    const { accurateTimeOffset, timeOffset } = this.currentTransmuxState;\n    logger.log(\n      `[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${\n        chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''\n      } of level ${chunkMeta.level}`\n    );\n    const remuxResult = this.remuxer!.remux(\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack,\n      timeOffset,\n      accurateTimeOffset,\n      true,\n      this.id\n    );\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta,\n    });\n\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n\n  resetInitialTimestamp(defaultInitPts: RationalTimestamp | null) {\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n\n  resetContiguity() {\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n\n  resetInitSegment(\n    initSegmentData: Uint8Array | undefined,\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    trackDuration: number,\n    decryptdata: DecryptData | null\n  ) {\n    const { demuxer, remuxer } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(\n      initSegmentData,\n      audioCodec,\n      videoCodec,\n      trackDuration\n    );\n    remuxer.resetInitSegment(\n      initSegmentData,\n      audioCodec,\n      videoCodec,\n      decryptdata\n    );\n  }\n\n  destroy(): void {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n\n  private transmux(\n    data: Uint8Array,\n    keyData: KeyData | null,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    chunkMeta: ChunkMetadata\n  ): TransmuxerResult | Promise<TransmuxerResult> {\n    let result: TransmuxerResult | Promise<TransmuxerResult>;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(\n        data,\n        keyData,\n        timeOffset,\n        accurateTimeOffset,\n        chunkMeta\n      );\n    } else {\n      result = this.transmuxUnencrypted(\n        data,\n        timeOffset,\n        accurateTimeOffset,\n        chunkMeta\n      );\n    }\n    return result;\n  }\n\n  private transmuxUnencrypted(\n    data: Uint8Array,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    chunkMeta: ChunkMetadata\n  ): TransmuxerResult {\n    const { audioTrack, videoTrack, id3Track, textTrack } = (\n      this.demuxer as Demuxer\n    ).demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer!.remux(\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack,\n      timeOffset,\n      accurateTimeOffset,\n      false,\n      this.id\n    );\n    return {\n      remuxResult,\n      chunkMeta,\n    };\n  }\n\n  private transmuxSampleAes(\n    data: Uint8Array,\n    decryptData: KeyData,\n    timeOffset: number,\n    accurateTimeOffset: boolean,\n    chunkMeta: ChunkMetadata\n  ): Promise<TransmuxerResult> {\n    return (this.demuxer as Demuxer)\n      .demuxSampleAes(data, decryptData, timeOffset)\n      .then((demuxResult) => {\n        const remuxResult = this.remuxer!.remux(\n          demuxResult.audioTrack,\n          demuxResult.videoTrack,\n          demuxResult.id3Track,\n          demuxResult.textTrack,\n          timeOffset,\n          accurateTimeOffset,\n          false,\n          this.id\n        );\n        return {\n          remuxResult,\n          chunkMeta,\n        };\n      });\n  }\n\n  private configureTransmuxer(data: Uint8Array): void | Error {\n    const { config, observer, typeSupported, vendor } = this;\n    // probe for content type\n    let mux: MuxConfig | null = null;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      if (muxConfig[i].demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    }\n  }\n\n  private needsProbing(discontinuity: boolean, trackSwitch: boolean): boolean {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n\n  private getDecrypter(): Decrypter {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\n\nfunction getEncryptionType(\n  data: Uint8Array,\n  decryptData: DecryptData | null\n): KeyData | null {\n  let encryptionType: KeyData | null = null;\n  if (\n    data.byteLength > 0 &&\n    decryptData != null &&\n    decryptData.key != null &&\n    decryptData.iv !== null &&\n    decryptData.method != null\n  ) {\n    encryptionType = decryptData as KeyData;\n  }\n  return encryptionType;\n}\n\nconst emptyResult = (chunkMeta): TransmuxerResult => ({\n  remuxResult: {},\n  chunkMeta,\n});\n\nexport function isPromise<T>(p: Promise<T> | any): p is Promise<T> {\n  return 'then' in p && p.then instanceof Function;\n}\n\nexport class TransmuxConfig {\n  public audioCodec?: string;\n  public videoCodec?: string;\n  public initSegmentData?: Uint8Array;\n  public duration: number;\n  public defaultInitPts: RationalTimestamp | null;\n\n  constructor(\n    audioCodec: string | undefined,\n    videoCodec: string | undefined,\n    initSegmentData: Uint8Array | undefined,\n    duration: number,\n    defaultInitPts?: RationalTimestamp\n  ) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\n\nexport class TransmuxState {\n  public discontinuity: boolean;\n  public contiguous: boolean;\n  public accurateTimeOffset: boolean;\n  public trackSwitch: boolean;\n  public timeOffset: number;\n  public initSegmentChange: boolean;\n\n  constructor(\n    discontinuity: boolean,\n    contiguous: boolean,\n    accurateTimeOffset: boolean,\n    trackSwitch: boolean,\n    timeOffset: number,\n    initSegmentChange: boolean\n  ) {\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import Transmuxer, { isPromise } from '../demux/transmuxer';\nimport { Events } from '../events';\nimport { ILogFunction, enableLogs, logger } from '../utils/logger';\nimport { EventEmitter } from 'eventemitter3';\nimport { ErrorDetails, ErrorTypes } from '../errors';\nimport type { RemuxedTrack, RemuxerResult } from '../types/remuxer';\nimport type { TransmuxerResult, ChunkMetadata } from '../types/transmuxer';\n\nif (typeof __IN_WORKER__ !== 'undefined' && __IN_WORKER__) {\n  startWorker(self);\n}\n\nfunction startWorker(self) {\n  const observer = new EventEmitter();\n  const forwardMessage = (ev, data) => {\n    self.postMessage({ event: ev, data: data });\n  };\n\n  // forward events to main thread\n  observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n  observer.on(Events.ERROR, forwardMessage);\n\n  // forward logger events to main thread\n  const forwardWorkerLogs = () => {\n    for (const logFn in logger) {\n      const func: ILogFunction = (message?) => {\n        forwardMessage('workerLog', {\n          logType: logFn,\n          message,\n        });\n      };\n\n      logger[logFn] = func;\n    }\n  };\n\n  self.addEventListener('message', (ev) => {\n    const data = ev.data;\n    switch (data.cmd) {\n      case 'init': {\n        const config = JSON.parse(data.config);\n        self.transmuxer = new Transmuxer(\n          observer,\n          data.typeSupported,\n          config,\n          data.vendor,\n          data.id\n        );\n        enableLogs(config.debug, data.id);\n        forwardWorkerLogs();\n        forwardMessage('init', null);\n        break;\n      }\n      case 'configure': {\n        self.transmuxer.configure(data.config);\n        break;\n      }\n      case 'demux': {\n        const transmuxResult: TransmuxerResult | Promise<TransmuxerResult> =\n          self.transmuxer.push(\n            data.data,\n            data.decryptdata,\n            data.chunkMeta,\n            data.state\n          );\n        if (isPromise(transmuxResult)) {\n          self.transmuxer.async = true;\n          transmuxResult\n            .then((data) => {\n              emitTransmuxComplete(self, data);\n            })\n            .catch((error) => {\n              forwardMessage(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                chunkMeta: data.chunkMeta,\n                fatal: false,\n                error,\n                err: error,\n                reason: `transmuxer-worker push error`,\n              });\n            });\n        } else {\n          self.transmuxer.async = false;\n          emitTransmuxComplete(self, transmuxResult);\n        }\n        break;\n      }\n      case 'flush': {\n        const id = data.chunkMeta;\n        let transmuxResult = self.transmuxer.flush(id);\n        const asyncFlush = isPromise(transmuxResult);\n        if (asyncFlush || self.transmuxer.async) {\n          if (!isPromise(transmuxResult)) {\n            transmuxResult = Promise.resolve(transmuxResult);\n          }\n          transmuxResult\n            .then((results: Array<TransmuxerResult>) => {\n              handleFlushResult(self, results as Array<TransmuxerResult>, id);\n            })\n            .catch((error) => {\n              forwardMessage(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                chunkMeta: data.chunkMeta,\n                fatal: false,\n                error,\n                err: error,\n                reason: `transmuxer-worker flush error`,\n              });\n            });\n        } else {\n          handleFlushResult(\n            self,\n            transmuxResult as Array<TransmuxerResult>,\n            id\n          );\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  });\n}\n\nfunction emitTransmuxComplete(\n  self: any,\n  transmuxResult: TransmuxerResult\n): boolean {\n  if (isEmptyResult(transmuxResult.remuxResult)) {\n    return false;\n  }\n  const transferable: Array<ArrayBuffer> = [];\n  const { audio, video } = transmuxResult.remuxResult;\n  if (audio) {\n    addToTransferable(transferable, audio);\n  }\n  if (video) {\n    addToTransferable(transferable, video);\n  }\n  self.postMessage(\n    { event: 'transmuxComplete', data: transmuxResult },\n    transferable\n  );\n  return true;\n}\n\n// Converts data to a transferable object https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast)\n// in order to minimize message passing overhead\nfunction addToTransferable(\n  transferable: Array<ArrayBuffer>,\n  track: RemuxedTrack\n) {\n  if (track.data1) {\n    transferable.push(track.data1.buffer);\n  }\n  if (track.data2) {\n    transferable.push(track.data2.buffer);\n  }\n}\n\nfunction handleFlushResult(\n  self: any,\n  results: Array<TransmuxerResult>,\n  chunkMeta: ChunkMetadata\n) {\n  const parsed = results.reduce(\n    (parsed, result) => emitTransmuxComplete(self, result) || parsed,\n    false\n  );\n  if (!parsed) {\n    // Emit at least one \"transmuxComplete\" message even if media is not found to update stream-controller state to PARSING\n    self.postMessage({ event: 'transmuxComplete', data: results[0] });\n  }\n  self.postMessage({ event: 'flush', data: chunkMeta });\n}\n\nfunction isEmptyResult(remuxResult: RemuxerResult) {\n  return (\n    !remuxResult.audio &&\n    !remuxResult.video &&\n    !remuxResult.text &&\n    !remuxResult.id3 &&\n    !remuxResult.initSegment\n  );\n}\n"],"names":["Events","ErrorTypes","ErrorDetails","AESCrypto","subtle","iv","this","aesIV","prototype","decrypt","data","key","name","FastAESKey","expandKey","importKey","sliceUint8","array","start","end","Uint8Array","slice","Array","call","AESDecryptor","rcon","subMix","Uint32Array","invSubMix","sBox","invSBox","ksRows","keySize","keySchedule","invKeySchedule","initTable","_proto","uint8ArrayToUint32Array_","arrayBuffer","view","DataView","newArray","i","getUint32","subMix0","subMix1","subMix2","subMix3","invSubMix0","invSubMix1","invSubMix2","invSubMix3","d","x","xi","sx","x2","x4","x8","t","keyBuffer","sameKey","offset","length","Error","ksRow","invKsRow","prev","sbox","networkToHostOrderSwap","word","inputArrayBuffer","t0","t1","t2","t3","s0","s1","s2","s3","inputWords0","inputWords1","inputWords2","inputWords3","nRounds","invSBOX","initVector","initVector0","initVector1","initVector2","initVector3","inputInt32","Int32Array","outputInt32","swapWord","buffer","noop","fakeLogger","trace","debug","log","warn","info","error","exportedLogger","consolePrintFn","type","func","self","console","bind","enableLogs","debugConfig","id","_len","arguments","functions","_key","forEach","exportLoggerFunctions","undefined","e","logger","isFiniteNumber","Number","isFinite","value","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","opts","trim","alwaysNormalize","basePartsForNormalise","parseURL","path","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","pathParts","exec","builtParts","params","query","fragment","baseURLPath","newPath","substring","lastIndexOf","url","parts","split","reverse","join","replace","decoder","isHeader","isFooter","getID3Data","front","readSize","subarray","size","canParse","isTimeStampFrame","frame","getFrameData","String","fromCharCode","getID3Frames","id3Data","frames","frameData","decodeFrame","push","decodePrivFrame","decodeURLFrame","decodeTextFrame","owner","utf8ArrayToStr","privateData","index","description","text","readTimeStamp","timeStampFrame","byteLength","pts33Bit","timestamp","Math","round","exitOnNull","getTextDecoder","decoded","decode","idx","indexOf","c","char2","char3","len","out","TextDecoder","appendUint8Array","data1","data2","temp","set","Decrypter","config","_temp","_ref$removePKCS7Paddi","removePKCS7Padding","logEnabled","softwareDecrypter","fastAesKey","remainderData","currentIV","currentResult","useSoftware","enableSoftwareAES","browserCrypto","crypto","webkitSubtle","destroy","isSync","flush","reset","outputBytes","paddingBytes","getUint8","_this","Promise","resolve","reject","softwareDecrypt","decryptResult","webCryptoDecrypt","logOnce","currentChunk","getValidChunk","result","_this2","then","aesKey","catch","err","message","onWebCryptoError","splitPoint","msg","MetadataSchema","dummyTrack","inputTimeScale","pid","sequenceNumber","samples","dropped","BaseAudioDemuxer","_audioTrack","_id3Track","frameIndex","cachedData","basePTS","initPTS","lastPTS","resetInitSegment","initSegment","audioCodec","videoCodec","trackDuration","resetTimeStamp","deaultTimestamp","resetContiguity","appendFrame","track","demux","timeOffset","lastDataIndex","ID3","id3Track","_isFiniteNumber","initPTSFn","pts","dts","duration","POSITIVE_INFINITY","sample","partialData","audioTrack","videoTrack","textTrack","demuxSampleAes","keyData","_isFiniteNumber2","baseTime","timescale","chromeVersion","BitratesMap","SamplingRateMap","SamplesCoefficients","BytesInSlot","parseHeader","mpegVersion","mpegLayer","bitRateIndex","sampleRateIndex","paddingBit","channelMode","bitRate","sampleRate","channelCount","sampleCoefficient","bytesInSlot","samplesPerFrame","frameLength","floor","navigator","userAgent","match","parseInt","isHeaderPattern","probe","header","newOffset","MP3Demuxer","_BaseAudioDemuxer","apply","container","segmentCodec","manifestCodec","MpegAudio","stamp","unit","samplerate","missing","AAC","getSilentFrame","codec","UINT32_MAX","pow","MP4","init","types","avc1","avcC","btrt","dinf","dref","esds","ftyp","hdlr","mdat","mdhd","mdia","mfhd","minf","moof","moov","mp4a","mvex","mvhd","pasp","sdtp","stbl","stco","stsc","stsd","stsz","stts","tfdt","tfhd","traf","trak","trun","trex","tkhd","vmhd","smhd","hasOwnProperty","charCodeAt","videoHdlr","audioHdlr","HDLR_TYPES","video","audio","STTS","STSC","STCO","STSZ","VMHD","SMHD","STSD","majorBrand","avc1Brand","minorVersion","FTYP","box","DINF","payload","upperWordDuration","lowerWordDuration","sn","baseMediaDecodeTime","tracks","boxes","concat","bytes","flags","dependsOn","isDependedOn","hasRedundancy","sps","pps","avcc","width","height","hSpacing","pixelRatio","vSpacing","configlen","mp3","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","cts","arraylen","isLeading","paddingValue","isNonSync","degradPrio","movie","PlaylistLevelType","toMsFromMpegTsClock","destScale","srcBase","toTimescaleFromBase","safariWebkitVersion","MP4Remuxer","observer","typeSupported","vendor","ISGenerated","_initPTS","_initDTS","nextAvcDts","nextAudioPts","videoSampleDuration","isAudioContiguous","isVideoContiguous","defaultTimeStamp","resetNextTimestamp","getVideoStartPts","videoSamples","rolloverDetected","startPTS","reduce","minPTS","delta","normalizePts","remux","accurateTimeOffset","playlistType","id3","independent","audioTimeOffset","videoTimeOffset","hasAudio","hasVideo","enoughAudioSamples","enoughVideoSamples","generateIS","firstKeyFramePTS","firstKeyFrameIndex","findKeyframeIndex","forceKeyFrameOnDiscontinuity","audiovideoTimestampDelta","max","remuxAudio","audioTrackLength","endPTS","remuxVideo","firstKeyFrame","initDTS","flushTextTrackMetadataCueSamples","sort","a","b","flushTextTrackUserdataCueSamples","audioSamples","computePTSDTS","Infinity","mpeg","metadata","startOffset","min","Object","keys","contiguous","firstDTS","lastDTS","timeScale","inputSamples","outputSamples","nbSamples","mp4SampleDuration","maxPTS","NEGATIVE_INFINITY","sortSamples","initTime","deltadts","deltapts","inputDuration","averageSampleDuration","foundHole","foundOverlap","firstPTS","nbNalu","naluLen","units","nbUnits","sampleLen","j","mdatSize","emit","ERROR","MUX_ERROR","details","REMUX_ALLOC_ERROR","fatal","reason","setUint32","stretchedLastFrame","minDtsDelta","minPtsDelta","maxDtsDelta","maxPtsDelta","avcSample","avcSampleUnits","mp4SampleLength","unitData","unitDataLen","ptsDelta","lastFrameDuration","stretchShortVideoTrack","gapTolerance","maxBufferHole","deltaToFrameEnd","compositionTimeOffset","Mp4Sample","nextDts","nextPts","_extends","startDTS","endDTS","nb","scaleFactor","inputSampleDuration","rawMPEG","alignedWithVideo","timeOffsetMpegTS","abs","filter","maxAudioFramesDrift","toFixed","newStamp","fillFrame","splice","sampleLength","audioSample","unitLen","lastSample","audioData","remuxEmptyAudio","videoData","init90kHz","frameDuration","ceil","silentFrame","reference","now","isKeyframe","Mp4SampleFlags","performance","Date","muxConfig","Transmuxer","async","demuxer","remuxer","decrypter","decryptionPromise","transmuxConfig","currentTransmuxState","configure","decryptdata","chunkMeta","state","stats","transmuxing","executeStart","uintData","_ref","discontinuity","trackSwitch","initSegmentChange","defaultInitPts","initSegmentData","decryptData","encryptionType","method","getEncryptionType","getDecrypter","decryptedData","part","executeEnd","emptyResult","resetMuxers","needsProbing","configureTransmuxer","MEDIA_ERROR","FRAG_PARSING_ERROR","resetInitialTimestamp","transmux","currentState","transmuxResults","demuxResultOrPromise","isPromise","demuxResult","flushRemux","_this$currentTransmux","level","remuxResult","transmuxSampleAes","transmuxUnencrypted","_demux","progressive","_this3","mux","Remuxer","Demuxer","p","Function","has","prefix","EE","fn","context","once","addListener","emitter","event","TypeError","listener","evt","_events","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","names","getOwnPropertySymbols","listeners","handlers","l","ee","listenerCount","a1","a2","a3","a4","a5","args","removeListener","on","removeAllListeners","off","prefixed","module","exports","emitTransmuxComplete","transmuxResult","transferable","_transmuxResult$remux","addToTransferable","postMessage","handleFlushResult","results","parsed","forwardMessage","ev","FRAG_DECRYPTED","forwardWorkerLogs","_loop","logFn","logType","addEventListener","cmd","JSON","parse","transmuxer","startWorker"],"mappings":"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AC5D,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAC5D,GAAM,IAGV,GAGLoU,CAAA,CAzEM,GCKHG,GAAatJ,KAAKuJ,IAAI,EAAG,IAAM,EAE/BC,GAAG,WAAA,SAAAA,IAAA,CA0mCN,OA1mCMA,EAaAC,KAAP,WAwCE,IAAIpT,EACJ,IAAKA,KAxCLmT,EAAIE,MAAQ,CACVC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACN,OAAQ,GACRC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,IAIErC,EAAIE,MACRF,EAAIE,MAAMoC,eAAezV,KAC3BmT,EAAIE,MAAMrT,GAAK,CACbA,EAAE0V,WAAW,GACb1V,EAAE0V,WAAW,GACb1V,EAAE0V,WAAW,GACb1V,EAAE0V,WAAW,KAKnB,IAAMC,EAAY,IAAIjX,WAAW,CAC/B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGIkX,EAAY,IAAIlX,WAAW,CAC/B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAGFyU,EAAI0C,WAAa,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BiL,EAAMsD,cAA0C,QAAhBtD,EAAM+D,MACjCG,EAAIwD,IAAIxD,EAAIE,MAAMwB,KAAM1B,EAAImD,KAAMnD,EAAIgF,IAAIlJ,IAG5CkE,EAAIwD,IAAIxD,EAAIE,MAAMwB,KAAM1B,EAAImD,KAAMnD,EAAIkB,KAAKpF,IAE3CkE,EAAIwD,IAAIxD,EAAIE,MAAMwB,KAAM1B,EAAImD,KAAMnD,EAAIG,KAAKrE,KAErDkE,EAEMmC,KAAP,SAAYrG,GACV,IAAM1K,EAAK0K,EAAM1K,GACXoL,EAAWV,EAAMU,SAAWV,EAAMqB,UAClCuH,EAAQ5I,EAAM4I,MACdC,EAAS7I,EAAM6I,OACfhB,EAAoBnN,KAAK+H,MAAM/B,GAAYsD,GAAa,IACxD8D,EAAoBpN,KAAK+H,MAAM/B,GAAYsD,GAAa,IAC9D,OAAOE,EAAIwD,IACTxD,EAAIE,MAAMiC,KACV,IAAI5W,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACC6F,GAAM,GAAM,IACZA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,EACA,EACA,EACA,EACA,EACAuS,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACAC,GAAqB,GACpBA,GAAqB,GAAM,IAC3BA,GAAqB,EAAK,IACP,IAApBA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACCc,GAAS,EAAK,IACP,IAARA,EACA,EACA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,MAGL3E,EAEM+B,KAAP,SAAYjG,EAAOgI,GACjB,IAAMmB,EAAwBjF,EAAIsB,KAAKxF,GACjC1K,EAAK0K,EAAM1K,GACX8T,EAA+B1O,KAAK+H,MACxCuF,GAAuBhE,GAAa,IAEhCqF,EAA+B3O,KAAK+H,MACxCuF,GAAuBhE,GAAa,IAEtC,OAAOE,EAAIwD,IACTxD,EAAIE,MAAM6B,KACV/B,EAAIwD,IACFxD,EAAIE,MAAM4B,KACV,IAAIvW,WAAW,CACb,EACA,EACA,EACA,EACA6F,GAAM,GACLA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,KAGJ4O,EAAIwD,IACFxD,EAAIE,MAAM2B,KACV,IAAItW,WAAW,CACb,EACA,EACA,EACA,EACA2Z,GAAgC,GAC/BA,GAAgC,GAAM,IACtCA,GAAgC,EAAK,IACP,IAA/BA,EACAC,GAAgC,GAC/BA,GAAgC,GAAM,IACtCA,GAAgC,EAAK,IACP,IAA/BA,KAGJnF,EAAIiC,KACFnG,EACAmJ,EAAsB/W,OACpB,GACA,GACA,EACA,GACA,EACA,GAEJ+W,EAEJ,EAEAjF,EAIOgC,KAAP,SAAYlG,GAEV,OADAA,EAAMU,SAAWV,EAAMU,UAAY,WAC5BwD,EAAIwD,IAAIxD,EAAIE,MAAM8B,KAAMhC,EAAImC,KAAKrG,GAAQkE,EAAIa,KAAK/E,KAC1DkE,EAEMkC,KAAP,SAAYpG,GACV,IAAM1K,EAAK0K,EAAM1K,GACjB,OAAO4O,EAAIwD,IACTxD,EAAIE,MAAMgC,KACV,IAAI3W,WAAW,CACb,EACA,EACA,EACA,EACA6F,GAAM,GACLA,GAAM,GAAM,IACZA,GAAM,EAAK,IACP,IAALA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,MAGL4O,EAEMiC,KAAP,SAAYnG,EAAO7N,GACjB,IAIIpB,EACA6P,EACAF,EACA3H,EACAsP,EACAiB,EATEzK,EAAUmB,EAAMnB,SAAW,GAC3BxD,EAAMwD,EAAQzM,OACdmX,EAAW,GAAK,GAAKlO,EACrB/L,EAAQ,IAAIG,WAAW8Z,GAyB7B,IAlBApX,GAAU,EAAIoX,EACdja,EAAMsM,IACJ,CACiB,UAAfoE,EAAMjL,KAAmB,EAAO,EAChC,EACA,GACA,EACCsG,IAAQ,GAAM,IACdA,IAAQ,GAAM,IACdA,IAAQ,EAAK,IACR,IAANA,EACClJ,IAAW,GAAM,IACjBA,IAAW,GAAM,IACjBA,IAAW,EAAK,IACR,IAATA,GAEF,GAEGpB,EAAI,EAAGA,EAAIsK,EAAKtK,IAEnB2P,GADAE,EAAS/B,EAAQ9N,IACC2P,SAClB3H,EAAO6H,EAAO7H,KACdsP,EAAQzH,EAAOyH,MACfiB,EAAM1I,EAAO0I,IACbha,EAAMsM,IACJ,CACG8E,IAAa,GAAM,IACnBA,IAAa,GAAM,IACnBA,IAAa,EAAK,IACR,IAAXA,EACC3H,IAAS,GAAM,IACfA,IAAS,GAAM,IACfA,IAAS,EAAK,IACR,IAAPA,EACCsP,EAAMmB,WAAa,EAAKnB,EAAMC,UAC9BD,EAAME,cAAgB,EACpBF,EAAMG,eAAiB,EACvBH,EAAMoB,cAAgB,EACvBpB,EAAMqB,UACY,MAApBrB,EAAMsB,WACa,GAAnBtB,EAAMsB,WACLL,IAAQ,GAAM,IACdA,IAAQ,GAAM,IACdA,IAAQ,EAAK,IACR,IAANA,GAEF,GAAK,GAAKvY,GAGd,OAAOmT,EAAIwD,IAAIxD,EAAIE,MAAM+B,KAAM7W,IAChC4U,EAEM1E,YAAP,SAAmByI,GACZ/D,EAAIE,OACPF,EAAIC,OAGN,IAAMyF,EAAQ1F,EAAIiB,KAAK8C,GACjBnK,EAAS,IAAIrO,WAAWyU,EAAIuD,KAAKlN,WAAaqP,EAAMrP,YAG1D,OAFAuD,EAAOlC,IAAIsI,EAAIuD,MACf3J,EAAOlC,IAAIgO,EAAO1F,EAAIuD,KAAKlN,YACpBuD,GACRoG,CAAA,CA1mCM,GAAHA,GACUE,WAAK,EADfF,GAEW0C,gBAAU,EAFrB1C,GAGW6C,UAAI,EAHf7C,GAIW8C,UAAI,EAJf9C,GAKW+C,UAAI,EALf/C,GAMWgD,UAAI,EANfhD,GAOWiD,UAAI,EAPfjD,GAQWkD,UAAI,EARflD,GASWmD,UAAI,EATfnD,GAUWuD,UAAI,EAVfvD,GAWWyD,UAAI,ECuJrB,IAAkBkC,GAAiB,QCnJ5B,SAASC,GACd1I,EACAzG,GAEA,YAFc,IAAdA,IAAAA,GAAiB,GArBZ,SACLyG,EACA2I,EACAC,EACArP,QADe,IAAfqP,IAAAA,EAAkB,QACJ,IAAdrP,IAAAA,GAAiB,GAEjB,IAAMmD,EAASsD,EAAW2I,EAAYC,EACtC,OAAOrP,EAAQD,KAAKC,MAAMmD,GAAUA,CACtC,CAeSmM,CAAoB7I,EAAU,IAAM,EA9Bf,IA8B0CzG,EACxE,CCCA,IAII2G,GAA+B,KAC/B4I,GAAqC,KAEpBC,GAAU,WAa7B,SAAAA,EACEC,EACAtO,EACAuO,EACAC,GAOA,GAPW3b,KAhBLyb,cAAQ,EAAAzb,KACRmN,YAAM,EAAAnN,KACN0b,mBAAa,EAAA1b,KACb4b,aAAuB,EAAK5b,KAC5B6b,SAAqC,KAAI7b,KACzC8b,SAAqC,KAAI9b,KACzC+b,WAA4B,KAAI/b,KAChCgc,aAA8B,KAAIhc,KAClCic,oBAAqC,KAAIjc,KACzCkc,mBAA6B,EAAKlc,KAClCmc,mBAA6B,EAQnCnc,KAAKyb,SAAWA,EAChBzb,KAAKmN,OAASA,EACdnN,KAAK0b,cAAgBA,EACrB1b,KAAK4b,aAAc,EAEG,OAAlBjJ,GAAwB,CAC1B,IACMxD,GADY4E,UAAUC,WAAa,IAChBC,MAAM,kBAC/BtB,GAAgBxD,EAAS+E,SAAS/E,EAAO,IAAM,CACjD,CACA,GAA4B,OAAxBoM,GAA8B,CAChC,IAAMpM,EAAS4E,UAAUC,UAAUC,MAAM,kBACzCsH,GAAsBpM,EAAS+E,SAAS/E,EAAO,IAAM,CACvD,CACF,CAAC,IAAArN,EAAA0Z,EAAAtb,UA27BA,OA37BA4B,EAEDoM,QAAA,aAAYpM,EAEZmP,eAAA,SAAemL,GACbhV,EAAOtB,IAAI,0CACX9F,KAAK6b,SAAW7b,KAAK8b,SAAWM,GACjCta,EAEDua,mBAAA,WACEjV,EAAOtB,IAAI,uCACX9F,KAAKmc,mBAAoB,EACzBnc,KAAKkc,mBAAoB,GAC1Bpa,EAED8O,iBAAA,WACExJ,EAAOtB,IAAI,yCACX9F,KAAK4b,aAAc,GACpB9Z,EAEDwa,iBAAA,SAAiBC,GACf,IAAIC,GAAmB,EACjBC,EAAWF,EAAaG,QAAO,SAACC,EAAQ1K,GAC5C,IAAM2K,EAAQ3K,EAAOJ,IAAM8K,EAC3B,OAAIC,GAAS,YAEXJ,GAAmB,EACZK,GAAaF,EAAQ1K,EAAOJ,MAC1B+K,EAAQ,EACVD,EAEA1K,EAAOJ,GAEjB,GAAE0K,EAAa,GAAG1K,KAInB,OAHI2K,GACFpV,EAAOvB,MAAM,yBAER4W,GACR3a,EAEDgb,MAAA,SACE3K,EACAC,EACAV,EACAW,EACAd,EACAwL,EACA3O,EACA4O,GAEA,IAAI9E,EACAC,EACAtH,EACApF,EACAwR,EACAC,EACAC,EAAkB5L,EAClB6L,EAAkB7L,EAOhB8L,EAAWlL,EAAWnC,KAAO,EAC7BsN,EAAWlL,EAAWpC,KAAO,EAC7BvM,EAAS2O,EAAWlC,QAAQzM,OAC5B8Z,EAAqBpL,EAAWjC,QAAQzM,OAAS,EACjD+Z,EAAsBpP,GAAS3K,EAAS,GAAMA,EAAS,EAO7D,KALK4Z,GAAYE,MACXD,GAAYE,IAChBxd,KAAK4b,aACLxN,EAEe,CACVpO,KAAK4b,cACR/K,EAAc7Q,KAAKyd,WACjBtL,EACAC,EACAb,EACAwL,IAIJ,IAEIW,EAFEvB,EAAoBnc,KAAKmc,kBAC3BwB,GAAsB,EAG1B,GAAIH,IACFG,EA23BR,SAA2BzN,GACzB,IAAK,IAAI9N,EAAI,EAAGA,EAAI8N,EAAQzM,OAAQrB,IAClC,GAAI8N,EAAQ9N,GAAG/B,IACb,OAAO+B,EAGX,OAAQ,CACV,CAl4B6Bwb,CAAkBxL,EAAWlC,UAC7CiM,GAAqBnc,KAAKmN,OAAO0Q,8BAEpC,GADAX,GAAc,EACVS,EAAqB,EAAG,CAC1BvW,EAAOrB,KAAI,0BACiB4X,EAA6Bla,WAAAA,8CAEzD,IAAMgZ,EAAWzc,KAAKsc,iBAAiBlK,EAAWlC,SAClDkC,EAAWlC,QAAUkC,EAAWlC,QAAQnP,MAAM4c,GAC9CvL,EAAWjC,SAAWwN,EAItBD,EAHAN,IACGhL,EAAWlC,QAAQ,GAAG2B,IAAM4K,GAC7BrK,EAAWrC,cAEf,MAAmC,IAAxB4N,IACTvW,EAAOrB,KACsCtC,2CAAAA,oBAE7CyZ,GAAc,GAKpB,GAAIld,KAAK4b,YAAa,CACpB,GAAI2B,GAAsBC,EAAoB,CAK5C,IAAMf,EAAWzc,KAAKsc,iBAAiBlK,EAAWlC,SAG5C4N,GADJjB,GAAa1K,EAAWjC,QAAQ,GAAG2B,IAAK4K,GAAYA,GACXrK,EAAWrC,eACtDoN,GAAmBpR,KAAKgS,IAAI,EAAGD,GAC/BV,GAAmBrR,KAAKgS,IAAI,GAAID,EAClC,CAGA,GAAIP,GAwBF,GAtBKpL,EAAW6C,aACd5N,EAAOrB,KACL,2DAEF8K,EAAc7Q,KAAKyd,WACjBtL,EACAC,EACAb,EACAwL,IAGJ5E,EAAQnY,KAAKge,WACX7L,EACAgL,EACAnd,KAAKkc,kBACLa,EACAO,GACEE,GACAR,IAAiB9B,GACfkC,OACAlW,GAEFsW,EAAoB,CACtB,IAAMS,EAAmB9F,EAAQA,EAAM+F,OAAS/F,EAAMsE,SAAW,EAE5DrK,EAAWrC,iBACd3I,EAAOrB,KACL,2DAEF8K,EAAc7Q,KAAKyd,WACjBtL,EACAC,EACAb,EACAwL,IAGJ7E,EAAQlY,KAAKme,WACX/L,EACAgL,EACAjB,EACA8B,EAEJ,OACST,IACTtF,EAAQlY,KAAKme,WACX/L,EACAgL,EACAjB,EACA,IAGAjE,IACFA,EAAMkG,cAAgBT,EACtBzF,EAAMgF,aAAsC,IAAxBS,EACpBzF,EAAMwF,iBAAmBA,EAE7B,CACF,CAsBA,OAnBI1d,KAAK4b,aAAe5b,KAAK6b,UAAY7b,KAAK8b,WACxCpK,EAASxB,QAAQzM,SACnBwZ,EA8xBD,SACL5L,EACAE,EACAb,EACA2N,GAEA,IAAM5a,EAAS4N,EAAMnB,QAAQzM,OAC7B,IAAKA,EACH,OAGF,IADA,IAAMsM,EAAiBsB,EAAMtB,eACpBxE,EAAQ,EAAGA,EAAQ9H,EAAQ8H,IAAS,CAC3C,IAAM0G,EAASZ,EAAMnB,QAAQ3E,GAG7B0G,EAAOJ,IACLgL,GACE5K,EAAOJ,IAAOnB,EAAQ+B,SAAW1C,EAAkBW,EAAQgC,UAC3DnB,EAAaxB,GACXA,EACNkC,EAAOH,IACL+K,GACE5K,EAAOH,IAAOuM,EAAQ5L,SAAW1C,EAAkBsO,EAAQ3L,UAC3DnB,EAAaxB,GACXA,CACR,CACA,IAAMG,EAAUmB,EAAMnB,QAEtB,OADAmB,EAAMnB,QAAU,GACT,CACLA,QAAAA,EAEJ,CA7zBcoO,CACJ5M,EACAH,EACAvR,KAAK6b,SACL7b,KAAK8b,WAILzJ,EAAUnC,QAAQzM,SACpBgI,EAszBD,SACL4F,EACAE,EACAb,GAEA,IAAMjN,EAAS4N,EAAMnB,QAAQzM,OAC7B,IAAKA,EACH,OAIF,IADA,IAAMsM,EAAiBsB,EAAMtB,eACpBxE,EAAQ,EAAGA,EAAQ9H,EAAQ8H,IAAS,CAC3C,IAAM0G,EAASZ,EAAMnB,QAAQ3E,GAG7B0G,EAAOJ,IACLgL,GACE5K,EAAOJ,IAAOnB,EAAQ+B,SAAW1C,EAAkBW,EAAQgC,UAC3DnB,EAAaxB,GACXA,CACR,CACAsB,EAAMnB,QAAQqO,MAAK,SAACC,EAAGC,GAAC,OAAKD,EAAE3M,IAAM4M,EAAE5M,OACvC,IAAM3B,EAAUmB,EAAMnB,QAEtB,OADAmB,EAAMnB,QAAU,GACT,CACLA,QAAAA,EAEJ,CAj1BewO,CACLrM,EACAd,EACAvR,KAAK6b,YAKJ,CACL1D,MAAAA,EACAD,MAAAA,EACArH,YAAAA,EACAqM,YAAAA,EACAzR,KAAAA,EACAwR,IAAAA,IAEHnb,EAED2b,WAAA,SACEtL,EACAC,EACAb,EACAwL,GAEA,IAOIrM,EACA2N,EACA3L,EATEiM,EAAexM,EAAWjC,QAC1BqM,EAAenK,EAAWlC,QAC1BwL,EAAgB1b,KAAK0b,cACrBpC,EAAmB,CAAA,EACnBuC,EAAW7b,KAAK6b,SAClB+C,GAAiB/C,GAAYkB,EAC7BrI,EAAY,YAShB,GAJIkK,IACFlO,EAAU2N,EAAUQ,KAGlB1M,EAAWhF,QAAUwR,EAAalb,OAAQ,CAM5C,GADA0O,EAAWO,UAAYP,EAAW6C,WAE3B,QADC7C,EAAWwC,aAEX+G,EAAcoD,MAEhBpK,EAAY,aACZvC,EAAWiD,MAAQ,IACVsG,EAAcnB,MAEvBpI,EAAWiD,MAAQ,OAIzBkE,EAAOnB,MAAQ,CACbxR,GAAI,QACJ+N,UAAWA,EACXU,MAAOjD,EAAWiD,MAClBvE,YAC8B,QAA5BsB,EAAWwC,cAA0B+G,EAAcoD,KAC/C,IAAIhe,WAAW,GACfyU,GAAI1E,YAAY,CAACsB,IACvB4M,SAAU,CACRtL,aAActB,EAAWsB,eAGzBmL,IACFlM,EAAYP,EAAWpC,eAClB8L,GAAYnJ,IAAcmJ,EAASnJ,UAKtCkM,GAAgB,EAHhBlO,EAAU2N,EACRM,EAAa,GAAG9M,IAAM9F,KAAKC,MAAM0G,EAAYnB,GAKrD,CAEA,GAAIa,EAAW0H,KAAO1H,EAAW2H,KAAOwC,EAAa9Y,SAGnD2O,EAAWM,UAAYN,EAAWrC,eAClCuJ,EAAOpB,MAAQ,CACbvR,GAAI,OACJ+N,UAAW,YACXU,MAAOhD,EAAWgD,MAClBvE,YAAa0E,GAAI1E,YAAY,CAACuB,IAC9B2M,SAAU,CACR9E,MAAO7H,EAAW6H,MAClBC,OAAQ9H,EAAW8H,SAGnB0E,GAEF,GADAlM,EAAYN,EAAWrC,eAClB8L,GAAYnJ,IAAcmJ,EAASnJ,UAStCkM,GAAgB,MATiC,CACjD,IAAMnC,EAAWzc,KAAKsc,iBAAiBC,GACjCyC,EAAcjT,KAAKC,MAAM0G,EAAYnB,GAC3C8M,EAAUtS,KAAKkT,IACbZ,EACAxB,GAAaN,EAAa,GAAGzK,IAAK2K,GAAYuC,GAEhDtO,EAAU3E,KAAKkT,IAAIvO,EAAmB+L,EAAWuC,EACnD,CAMJ,GAAIE,OAAOC,KAAK7F,GAAQ7V,OAetB,OAdAzD,KAAK4b,aAAc,EACfgD,GACF5e,KAAK6b,SAAW,CACdpJ,SAAU/B,EACVgC,UAAWA,GAEb1S,KAAK8b,SAAW,CACdrJ,SAAU4L,EACV3L,UAAWA,IAGbhC,EAAUgC,OAAYxL,EAGjB,CACLoS,OAAAA,EACA5I,QAAAA,EACAgC,UAAAA,IAGL5Q,EAEDqc,WAAA,SACE9M,EACAE,EACA6N,EACAnB,GAEA,IAQIoB,EACAC,EATEC,EAAoBlO,EAAMtB,eAC1ByP,EAAiCnO,EAAMnB,QACvCuP,EAAkC,GAClCC,EAAYF,EAAa/b,OACzBiN,EAAU1Q,KAAK6b,SACjBE,EAAa/b,KAAK+b,WAClBvY,EAAS,EACTmc,EAAoB3f,KAAKic,oBAGzBU,EAAiBrV,OAAO0K,kBACxB4N,EAAiBtY,OAAOuY,kBACxBC,GAAc,EAGbV,GAA6B,OAAfrD,IAMjBA,EALYxK,EAAagO,GAEvBC,EAAa,GAAG3N,IAChBgL,GAAa2C,EAAa,GAAG1N,IAAK0N,EAAa,GAAG3N,OAQtD,IADA,IAAMkO,EAAYrP,EAAQ+B,SAAW8M,EAAa7O,EAAQgC,UACjDtQ,EAAI,EAAGA,EAAIsd,EAAWtd,IAAK,CAClC,IAAM6P,EAASuN,EAAapd,GAC5B6P,EAAOJ,IAAMgL,GAAa5K,EAAOJ,IAAMkO,EAAUhE,GACjD9J,EAAOH,IAAM+K,GAAa5K,EAAOH,IAAMiO,EAAUhE,GAC7C9J,EAAOH,IAAM0N,EAAapd,EAAI,EAAIA,EAAI,EAAIA,GAAG0P,MAC/CgO,GAAc,EAElB,CAGIA,GACFN,EAAajB,MAAK,SAAUC,EAAGC,GAC7B,IAAMuB,EAAWxB,EAAE1M,IAAM2M,EAAE3M,IACrBmO,EAAWzB,EAAE3M,IAAM4M,EAAE5M,IAC3B,OAAOmO,GAAYC,CACrB,IAIFZ,EAAWG,EAAa,GAAG1N,IAK3B,IAAMoO,GAJNZ,EAAUE,EAAaA,EAAa/b,OAAS,GAAGqO,KAIhBuN,EAC1Bc,EAAwBD,EAC1BnU,KAAKC,MAAMkU,GAAiBR,EAAY,IACxCC,GAAqBtO,EAAMtB,eAAiB,GAGhD,GAAIqP,EAAY,CAEd,IAAMxC,EAAQyC,EAAWtD,EACnBqE,EAAYxD,EAAQuD,EACpBE,EAAezD,GAAS,EAC9B,IAAIwD,GAAaC,KACXD,EACFhZ,EAAOrB,KACGoV,QAAAA,GACNyB,GACA,GACD,QAAQA,EAAK,oDAGhBxV,EAAOrB,KACGoV,QAAAA,IACLyB,GACD,GACOA,QAAAA,kDAGRyD,GAAgBtE,GAAcyD,EAAa,GAAG3N,KAAK,CACtDwN,EAAWtD,EACX,IAAMuE,EAAWd,EAAa,GAAG3N,IAAM+K,EACvC4C,EAAa,GAAG1N,IAAMuN,EACtBG,EAAa,GAAG3N,IAAMyO,EACtBlZ,EAAOtB,IAAG,kCAC0BqV,GAChCmF,GACA,GACD,IAAInF,GACHkE,GACA,GACD,YAAYlE,GAAoByB,GAAO,GAAK,MAEjD,CAEJ,CAEAyC,EAAWtT,KAAKgS,IAAI,EAAGsB,GAIvB,IAFA,IAAIkB,EAAS,EACTC,EAAU,EACLpe,EAAI,EAAGA,EAAIsd,EAAWtd,IAAK,CAMlC,IAJA,IAAM6P,EAASuN,EAAapd,GACtBqe,EAAQxO,EAAOwO,MACfC,EAAUD,EAAMhd,OAClBkd,EAAY,EACPC,EAAI,EAAGA,EAAIF,EAASE,IAC3BD,GAAaF,EAAMG,GAAGxgB,KAAKqD,OAG7B+c,GAAWG,EACXJ,GAAUG,EACVzO,EAAOxO,OAASkd,EAGhB1O,EAAOH,IAAM/F,KAAKgS,IAAI9L,EAAOH,IAAKuN,GAElC1C,EAAS5Q,KAAKkT,IAAIhN,EAAOJ,IAAK8K,GAC9BiD,EAAS7T,KAAKgS,IAAI9L,EAAOJ,IAAK+N,EAChC,CACAN,EAAUE,EAAaE,EAAY,GAAG5N,IAItC,IACIoE,EADE2K,EAAWL,EAAU,EAAID,EAAS,EAExC,IACErK,EAAO,IAAIpV,WAAW+f,EAWxB,CAVE,MAAOrR,GASP,YARAxP,KAAKyb,SAASqF,KAAKphB,EAAOqhB,MAAOrhB,EAAOqhB,MAAO,CAC7C3a,KAAMzG,EAAWqhB,UACjBC,QAASrhB,EAAashB,kBACtBC,OAAO,EACPlb,MAAOuJ,EACPiK,MAAOoH,EACPO,OAAsCP,8BAAAA,GAG1C,CACA,IAAM5e,EAAO,IAAIC,SAASgU,EAAKzQ,QAC/BxD,EAAKof,UAAU,EAAGR,GAClB3K,EAAKjJ,IAAIsI,GAAIE,MAAMS,KAAM,GAOzB,IALA,IAAIoL,GAAqB,EACrBC,EAAcja,OAAO0K,kBACrBwP,EAAcla,OAAO0K,kBACrByP,EAAcna,OAAOuY,kBACrB6B,EAAcpa,OAAOuY,kBAChBzd,EAAI,EAAGA,EAAIsd,EAAWtd,IAAK,CAKlC,IAJA,IAAMuf,EAAYnC,EAAapd,GACzBwf,EAAiBD,EAAUlB,MAC7BoB,EAAkB,EAEbjB,EAAI,EAAGF,EAAUkB,EAAene,OAAQmd,EAAIF,EAASE,IAAK,CACjE,IAAM7L,EAAO6M,EAAehB,GACtBkB,GAAW/M,EAAK3U,KAChB2hB,GAAchN,EAAK3U,KAAKwL,WAC9B3J,EAAKof,UAAU7d,EAAQue,IACvBve,GAAU,EACV0S,EAAKjJ,IAAI6U,GAAUte,GACnBA,GAAUue,GACVF,GAAmB,EAAIE,EACzB,CAGA,IAAIC,QAAQ,EACZ,GAAI5f,EAAIsd,EAAY,EAClBC,EAAoBH,EAAapd,EAAI,GAAG0P,IAAM6P,EAAU7P,IACxDkQ,GAAWxC,EAAapd,EAAI,GAAGyP,IAAM8P,EAAU9P,QAC1C,CACL,IAAM1E,GAASnN,KAAKmN,OACd8U,GACJ7f,EAAI,EACAuf,EAAU7P,IAAM0N,EAAapd,EAAI,GAAG0P,IACpCqO,EAKN,GAJA6B,GACE5f,EAAI,EACAuf,EAAU9P,IAAM2N,EAAapd,EAAI,GAAGyP,IACpCsO,EACFhT,GAAO+U,wBAAgD,OAAtBliB,KAAKgc,aAAuB,CAM/D,IAAMmG,GAAepW,KAAK+H,MAAM3G,GAAOiV,cAAgB7C,GACjD8C,IACHpE,EACGtB,EAASsB,EAAmBsB,EAC5Bvf,KAAKgc,cAAgB2F,EAAU9P,IACjCwQ,GAAkBF,KAGpBxC,EAAoB0C,GAAkBJ,IACd,EACtBtC,EAAoBsC,GAEpBX,GAAqB,EAEvBla,EAAOtB,IAAG,sCAENuc,GAAkB,GAAE,2CAEpB1C,EAAoB,GAAE,kCAI1BA,EAAoBsC,EAExB,MACEtC,EAAoBsC,EAExB,CACA,IAAMK,GAAwBvW,KAAKC,MAAM2V,EAAU9P,IAAM8P,EAAU7P,KACnEyP,EAAcxV,KAAKkT,IAAIsC,EAAa5B,GACpC8B,EAAc1V,KAAKgS,IAAI0D,EAAa9B,GACpC6B,EAAczV,KAAKkT,IAAIuC,EAAaQ,IACpCN,EAAc3V,KAAKgS,IAAI2D,EAAaM,IAEpCvC,EAAczU,KACZ,IAAIuX,GACFZ,EAAUthB,IACVsf,EACAkC,EACAS,IAGN,CAEA,GAAI7C,EAAchc,OAChB,GAAIkP,IACF,GAAIA,GAAgB,GAAI,CAGtB,IAAM+G,GAAQ+F,EAAc,GAAG/F,MAC/BA,GAAMC,UAAY,EAClBD,GAAMqB,UAAY,CACpB,OACK,GAAIQ,IAIPmG,EAAcF,EAAcC,EAAcF,GAC1CpB,EAAwBsB,EAAc,MACb,IAAzBhC,EAAc,GAAG9E,IACjB,CACAvT,EAAOrB,KACL,uGAGF,IADA,IAAI+L,GAAMuN,EACDjd,GAAI,EAAGsK,GAAM+S,EAAchc,OAAQrB,GAAIsK,GAAKtK,KAAK,CACxD,IAAMogB,GAAU1Q,GAAM2N,EAAcrd,IAAG2P,SACjCF,GAAMC,GAAM2N,EAAcrd,IAAGuY,IACnC,GAAIvY,GAAIsK,GAAM,EAAG,CACf,IAAM+V,GAAUD,GAAU/C,EAAcrd,GAAI,GAAGuY,IAC/C8E,EAAcrd,IAAG2P,SAAW0Q,GAAU5Q,EACxC,MACE4N,EAAcrd,IAAG2P,SAAW3P,GACxBqd,EAAcrd,GAAI,GAAG2P,SACrBoO,EAENV,EAAcrd,IAAGuY,IAAM,EACvB7I,GAAM0Q,EACR,CACF,CAIJ7C,EACE2B,IAAuB3B,EACnBQ,EACAR,EACN3f,KAAK+b,WAAaA,EAAauD,EAAUK,EACzC3f,KAAKic,oBAAsB0D,EAC3B3f,KAAKmc,mBAAoB,EACzB,IAQM/b,GAAO,CACX0M,MATWyI,GAAIgB,KACflF,EAAMpB,iBACNoP,EACAqD,EAAc,CAAE,EAAErR,EAAO,CACvBnB,QAASuP,KAMX1S,MAAOmJ,EACPuG,SAAUE,EAAS4C,EACnBrB,QAAS0B,EAASD,GAAqBJ,EACvCoD,SAAUtD,EAAWE,EACrBqD,OAAS7G,EAAwBwD,EACjCnZ,KAR6B,QAS7BiX,UAAU,EACVC,UAAU,EACVuF,GAAIpD,EAAchc,OAClB0M,QAASkB,EAAMlB,SAIjB,OAFAkB,EAAMnB,QAAU,GAChBmB,EAAMlB,QAAU,EACT/P,IACR0B,EAEDkc,WAAA,SACE3M,EACAE,EACA6N,EACArC,EACAK,GAEA,IAAMrN,EAAyBsB,EAAMtB,eAI/B+S,EAAsB/S,GAHCsB,EAAM2D,WAC/B3D,EAAM2D,WACNjF,GAEE4P,EACmB,QAAvBtO,EAAMsD,aAtrBkB,KACM,KAwrB1BoO,EAA8BpD,EAAoBmD,EAClDpS,EAAU1Q,KAAK6b,SACfmH,EACmB,QAAvB3R,EAAMsD,cAA0B3U,KAAK0b,cAAcoD,KAC/CW,EAAkC,GAClCwD,OAAuC/b,IAApBkW,EAErBoC,EAAmCnO,EAAMnB,QACzC1M,EAAiBwf,EAAU,EAAI,EAC/BhH,EAAuBhc,KAAKgc,eAAiB,EAY3CkH,EAAmB3R,EAAaxB,EAChCgQ,EAAYrP,EAAQ+B,SAAW1C,EAAkBW,EAAQgC,UAkB/D,GAjBA1S,KAAKkc,kBAAoBkD,EACvBA,GACEI,EAAa/b,QACbuY,EAAe,IACbe,GACAhR,KAAKoX,IAAID,EAAmBlH,GAAgB,KAC5CjQ,KAAKoX,IACHtG,GAAa2C,EAAa,GAAG3N,IAAMkO,EAAUmD,GAC3ClH,GAEF,GAAK+G,GAGbvD,EAAaxY,SAAQ,SAAUiL,GAC7BA,EAAOJ,IAAMgL,GAAa5K,EAAOJ,IAAMkO,EAAUmD,EACnD,KAEK9D,GAAcpD,EAAe,EAAG,CAOnC,GAHAwD,EAAeA,EAAa4D,QAAO,SAACnR,GAAM,OAAKA,EAAOJ,KAAO,MAGxD2N,EAAa/b,OAChB,OAKAuY,EAFsB,IAApBoB,EAEa,EACNL,IAAuBkG,EAEjBlX,KAAKgS,IAAI,EAAGmF,GAGZ1D,EAAa,GAAG3N,GAEnC,CAQA,GAA2B,QAAvBR,EAAMsD,aAER,IADA,IAAM0O,EAAsBrjB,KAAKmN,OAAOkW,oBAC/BjhB,EAAI,EAAGqgB,EAAUzG,EAAc5Z,EAAIod,EAAa/b,OAAQrB,IAAK,CAEpE,IAAM6P,EAASuN,EAAapd,GACtByP,EAAMI,EAAOJ,IACb+K,EAAQ/K,EAAM4Q,EACd1Q,EAAWhG,KAAKoX,IAAK,IAAOvG,EAAS7M,GAG3C,GACE6M,IAAUyG,EAAsBN,GAChCE,EAEU,IAAN7gB,IACFgF,EAAOrB,KAAI,kBACS8L,EAAM9B,GAAgBuT,QACtC,iCAC6BvX,KAAKC,MACjC,IAAO4Q,EAAS7M,GAClB,QAEH/P,KAAKgc,aAAeA,EAAeyG,EAAU5Q,QAS5C,GACH+K,GAASyG,EAAsBN,GAC/BhR,EAhyBwB,KAiyBxBkR,EACA,CACA,IAAIhO,EAAUlJ,KAAKC,MAAM4Q,EAAQmG,IAGjCN,EAAU5Q,EAAMoD,EAAU8N,GACZ,IACZ9N,IACAwN,GAAWM,GAEH,IAAN3gB,IACFpC,KAAKgc,aAAeA,EAAeyG,GAErCrb,EAAOrB,KAAI,4BACmBkP,EAAO,mBACjCwN,EAAU1S,GACVuT,QAAQ,GAAcvX,YAAAA,KAAKC,MAC1B,IAAO4Q,EAAS7M,GAClB,YAEH,IAAK,IAAI6Q,EAAI,EAAGA,EAAI3L,EAAS2L,IAAK,CAChC,IAAM2C,EAAWxX,KAAKgS,IAAI0E,EAAmB,GACzCe,EAAYtO,EAAIC,eAClB9D,EAAMuD,eAAiBvD,EAAM+D,MAC7B/D,EAAMoC,cAEH+P,IACHpc,EAAOtB,IACL,oGAEF0d,EAAYvR,EAAO8C,KAAK5K,YAE1BqV,EAAaiE,OAAOrhB,EAAG,EAAG,CACxB2S,KAAMyO,EACN3R,IAAK0R,IAEPd,GAAWM,EACX3gB,GACF,CACF,CACA6P,EAAOJ,IAAM4Q,EACbA,GAAWM,CACb,CAOF,IALA,IAEI7M,EAFAoK,EAA0B,KAC1B3P,EAAyB,KAEzBkQ,EAAmB,EACnB6C,EAAuBlE,EAAa/b,OACjCigB,KACL7C,GAAYrB,EAAakE,GAAc3O,KAAKnJ,WAE9C,IAAK,IAAIgV,EAAI,EAAGlB,EAAYF,EAAa/b,OAAQmd,EAAIlB,EAAWkB,IAAK,CACnE,IAAM+C,EAAcnE,EAAaoB,GAC3B7L,EAAO4O,EAAY5O,KACrBlD,EAAM8R,EAAY9R,IACtB,GAAgB,OAAZlB,EAAkB,CAGD8O,EAAcmB,EAAI,GAC1B7O,SAAWhG,KAAKC,OAAO6F,EAAMlB,GAAWmS,EACrD,KAAO,CAOL,GANI1D,GAAqC,QAAvB/N,EAAMsD,eAEtB9C,EAAMmK,GAGRsE,EAAWzO,IACPgP,EAAW,GAwBb,OArBAA,GAAYrd,EACZ,IACE0S,EAAO,IAAIpV,WAAW+f,EAWxB,CAVE,MAAOrR,GASP,YARAxP,KAAKyb,SAASqF,KAAKphB,EAAOqhB,MAAOrhB,EAAOqhB,MAAO,CAC7C3a,KAAMzG,EAAWqhB,UACjBC,QAASrhB,EAAashB,kBACtBC,OAAO,EACPlb,MAAOuJ,EACPiK,MAAOoH,EACPO,OAAsCP,8BAAAA,GAG1C,CACKmC,IACU,IAAI9gB,SAASgU,EAAKzQ,QAC1B4b,UAAU,EAAGR,GAClB3K,EAAKjJ,IAAIsI,GAAIE,MAAMS,KAAM,GAM/B,CACAA,EAAKjJ,IAAI8H,EAAMvR,GACf,IAAMogB,EAAU7O,EAAKnJ,WACrBpI,GAAUogB,EAIVnE,EAAczU,KAAK,IAAIuX,IAAU,EAAM5C,EAAmBiE,EAAS,IACnEjT,EAAUkB,CACZ,CAGA,IAAM6N,EAAYD,EAAchc,OAChC,GAAKic,EAAL,CAKA,IAAMmE,EAAapE,EAAcA,EAAchc,OAAS,GACxDzD,KAAKgc,aAAeA,EAClBrL,EAAWmS,EAAce,EAAW9R,SAGtC,IAAMwE,EAAOyM,EACT,IAAIliB,WAAW,GACfyU,GAAIgB,KACFlF,EAAMpB,iBACNqQ,EAAYwC,EACZJ,EAAc,CAAE,EAAErR,EAAO,CAAEnB,QAASuP,KAI1CpO,EAAMnB,QAAU,GAChB,IAAMtP,EAAQ0f,EAAYvQ,EACpBlP,EAAMmb,EAAejM,EAErB+T,EAAY,CAChBhX,MAAOyJ,EACPxJ,MAAOmJ,EACPuG,SAAU7b,EACVsd,OAAQrd,EACR8hB,SAAU/hB,EACVgiB,OAAQ/hB,EACRuF,KAR6B,QAS7BiX,UAAU,EACVC,UAAU,EACVuF,GAAInD,GAIN,OADA1f,KAAKkc,mBAAoB,EAClB4H,CAnCP,GAoCDhiB,EAEDiiB,gBAAA,SACE1S,EACAE,EACA6N,EACA4E,GAEA,IAAMjU,EAAyBsB,EAAMtB,eAI/B+S,EAAsB/S,GAHCsB,EAAM2D,WAC/B3D,EAAM2D,WACNjF,GAEEiM,EAA8Bhc,KAAKgc,aAEnCqC,EAAUre,KAAK8b,SACfmI,EAAgC,IAAnB5F,EAAQ5L,SAAoB4L,EAAQ3L,UACjDiQ,GACc,OAAjB3G,EACGA,EACAgI,EAAUrB,SAAW5S,GAAkBkU,EACvCrB,EAAiBoB,EAAUpB,OAAS7S,EAAiBkU,EAErDC,EAx8BoB,KAw8BIpB,EAExBpD,EAAoB3T,KAAKoY,MAAMvB,EAASD,GAAYuB,GAEpDE,EAAsClP,EAAIC,eAC9C9D,EAAMuD,eAAiBvD,EAAM+D,MAC7B/D,EAAMoC,cAKR,GAFArM,EAAOrB,KAAK,oCAEPqe,EAAL,CAQA,IADA,IAAMlU,EAAsB,GACnB9N,EAAI,EAAGA,EAAIsd,EAAWtd,IAAK,CAClC,IAAM0S,EAAQ6N,EAAWvgB,EAAI8hB,EAC7BhU,EAAQlF,KAAK,CAAE+J,KAAMqP,EAAavS,IAAKiD,EAAOhD,IAAKgD,GACrD,CAGA,OAFAzD,EAAMnB,QAAUA,EAETlQ,KAAKge,WAAW3M,EAAOE,EAAY6N,GAAY,EATtD,CAJEhY,EAAOxB,MACL,8GAaL4V,CAAA,CA59B4B,GA+9BxB,SAASqB,GAAarV,EAAe6c,GAC1C,IAAI7gB,EACJ,GAAkB,OAAd6gB,EACF,OAAO7c,EAaT,IAREhE,EAFE6gB,EAAY7c,GAEJ,WAGD,WAKJuE,KAAKoX,IAAI3b,EAAQ6c,GAAa,YACnC7c,GAAShE,EAGX,OAAOgE,CACT,CAuEC,IC/kCG8c,GDilCE/B,GAMJ,SACEgC,EACAxS,EACA3H,EACAuQ,GACA3a,KAVKoK,UAAI,EAAApK,KACJ+R,cAAQ,EAAA/R,KACR2a,SAAG,EAAA3a,KACH0Z,WAAK,EAQV1Z,KAAK+R,SAAWA,EAChB/R,KAAKoK,KAAOA,EACZpK,KAAK2a,IAAMA,EACX3a,KAAK0Z,MAAQ,IAAI8K,GAAeD,EAClC,EAGIC,GAQJ,SAAYD,GAAYvkB,KAPjB6a,UAAe,EAAC7a,KAChB4Z,aAAkB,EAAC5Z,KACnB6Z,cAAmB,EAAC7Z,KACpBgb,WAAgB,EAAChb,KACjB2Z,UAAmB,EAAC3Z,KACpB+a,UAAmB,EAGxB/a,KAAK2Z,UAAY4K,EAAa,EAAI,EAClCvkB,KAAK+a,UAAYwJ,EAAa,EAAI,CACpC,EC7mCF,IACED,GAAMhe,KAAKme,YAAYH,IAAI9d,KAAKF,KAAKme,YAIvC,CAHE,MAAOjV,GACPpI,EAAOvB,MAAM,qDACbye,GAAsB,oBAAThe,MAAwBA,KAAKoe,KAAKJ,GACjD,CAQA,IAAMK,GAAyB,CAI7B,CAAErT,MAAOiD,EAAYuI,MAAOtB,KAGToJ,GAAU,WAe7B,SAAAA,EACEnJ,EACAC,EACAvO,EACAwO,EACAhV,GACA3G,KApBK6kB,OAAiB,EAAK7kB,KACrByb,cAAQ,EAAAzb,KACR0b,mBAAa,EAAA1b,KACbmN,YAAM,EAAAnN,KACN2b,YAAM,EAAA3b,KACN2G,QAAE,EAAA3G,KACF8kB,aAAO,EAAA9kB,KACP+kB,aAAO,EAAA/kB,KACPglB,eAAS,EAAAhlB,KACToU,WAAK,EAAApU,KACLilB,kBAAsD,KAAIjlB,KAC1DklB,oBAAc,EAAAllB,KACdmlB,0BAAoB,EAS1BnlB,KAAKyb,SAAWA,EAChBzb,KAAK0b,cAAgBA,EACrB1b,KAAKmN,OAASA,EACdnN,KAAK2b,OAASA,EACd3b,KAAK2G,GAAKA,CACZ,CAAC,IAAA7E,EAAA8iB,EAAA1kB,UAkYA,OAlYA4B,EAEDsjB,UAAA,SAAUF,GACRllB,KAAKklB,eAAiBA,EAClBllB,KAAKglB,WACPhlB,KAAKglB,UAAU3W,SAElBvM,EAEDkJ,KAAA,SACE5K,EACAilB,EACAC,EACAC,GAC8C,IAAA9W,EAAAzO,KACxCwlB,EAAQF,EAAUG,YACxBD,EAAME,aAAepB,KAErB,IAAIqB,EAAuB,IAAI7kB,WAAWV,GAClC+kB,EAAyCnlB,KAAzCmlB,qBAAsBD,EAAmBllB,KAAnBklB,eAC1BK,IACFvlB,KAAKmlB,qBAAuBI,GAG9B,IAAAK,EAOIL,GAASJ,EANX/F,EAAUwG,EAAVxG,WACAyG,EAAaD,EAAbC,cACAC,EAAWF,EAAXE,YACA/I,EAAkB6I,EAAlB7I,mBACAxL,EAAUqU,EAAVrU,WACAwU,EAAiBH,EAAjBG,kBAGAjV,EAKEoU,EALFpU,WACAC,EAIEmU,EAJFnU,WACAiV,EAGEd,EAHFc,eACAjU,EAEEmT,EAFFnT,SACAkU,EACEf,EADFe,gBAGI1T,EA6VV,SACEnS,EACA8lB,GAEA,IAAIC,EAAiC,KAEnC/lB,EAAKwL,WAAa,GACH,MAAfsa,GACmB,MAAnBA,EAAY7lB,KACO,OAAnB6lB,EAAYnmB,IACU,MAAtBmmB,EAAYE,SAEZD,EAAiBD,GAEnB,OAAOC,CACT,CA5WoBE,CAAkBV,EAAUN,GAC5C,GAAI9S,GAA8B,YAAnBA,EAAQ6T,OAAsB,CAC3C,IAAMpB,EAAYhlB,KAAKsmB,eAEvB,IAAItB,EAAU7W,SAgCZ,OAbAnO,KAAKilB,kBAAoBD,EACtBjW,iBAAiB4W,EAAUpT,EAAQlS,IAAIoF,OAAQ8M,EAAQxS,GAAG0F,QAC1D4J,MAAK,SAACkX,GAGL,IAAMpX,EAASV,EAAKzD,KAClBub,EACA,KACAjB,GAGF,OADA7W,EAAKwW,kBAAoB,KAClB9V,CACT,IACKnP,KAAKilB,kBA7BZ,IAAIsB,EAAgBvB,EAAUnW,gBAC5B8W,EACApT,EAAQlS,IAAIoF,OACZ8M,EAAQxS,GAAG0F,QAOb,GAJqB6f,EAAUkB,MAAQ,IAErCD,EAAgBvB,EAAU5W,UAEvBmY,EAEH,OADAf,EAAMiB,WAAanC,KACZoC,GAAYpB,GAErBK,EAAW,IAAI7kB,WAAWylB,EAiB9B,CAEA,IAAMI,EAAc3mB,KAAK4mB,aAAaf,EAAeC,GACrD,GAAIa,EAAa,CACf,IAAM1gB,EAAQjG,KAAK6mB,oBAAoBlB,GACvC,GAAI1f,EAUF,OATAmB,EAAOrB,KAAI,gBAAiBE,EAAMwJ,SAClCzP,KAAKyb,SAASqF,KAAKphB,EAAOqhB,MAAOrhB,EAAOqhB,MAAO,CAC7C3a,KAAMzG,EAAWmnB,YACjB7F,QAASrhB,EAAamnB,mBACtB5F,OAAO,EACPlb,MAAAA,EACAmb,OAAQnb,EAAMwJ,UAEhB+V,EAAMiB,WAAanC,KACZoC,GAAYpB,EAEvB,EAEIO,GAAiBC,GAAeC,GAAqBY,IACvD3mB,KAAK4Q,iBACHqV,EACAnV,EACAC,EACAgB,EACAsT,IAIAQ,GAAiBE,GAAqBY,IACxC3mB,KAAKgnB,sBAAsBhB,GAGxB5G,GACHpf,KAAKmR,kBAGP,IAAMhC,EAASnP,KAAKinB,SAClBtB,EACApT,EACAhB,EACAwL,EACAuI,GAEI4B,EAAelnB,KAAKmlB,qBAO1B,OALA+B,EAAa9H,YAAa,EAC1B8H,EAAarB,eAAgB,EAC7BqB,EAAapB,aAAc,EAE3BN,EAAMiB,WAAanC,KACZnV,CACT,EAEArN,EACAsM,MAAA,SACEkX,GACkD,IAAAlW,EAAApP,KAC5CwlB,EAAQF,EAAUG,YACxBD,EAAME,aAAepB,KAErB,IAAQU,EAAuDhlB,KAAvDglB,UAAWG,EAA4CnlB,KAA5CmlB,qBAAsBF,EAAsBjlB,KAAtBilB,kBAEzC,GAAIA,EAGF,OAAOA,EAAkB5V,MAAK,WAC5B,OAAOD,EAAKhB,MAAMkX,EACpB,IAGF,IAAM6B,EAAsC,GACpC5V,EAAe4T,EAAf5T,WACR,GAAIyT,EAAW,CAIb,IAAMuB,EAAgBvB,EAAU5W,QAC5BmY,GAEFY,EAAgBnc,KACdhL,KAAKgL,KAAKub,EAAe,KAAMjB,GAGrC,CAEA,IAAQR,EAAqB9kB,KAArB8kB,QAASC,EAAY/kB,KAAZ+kB,QACjB,IAAKD,IAAYC,EAGf,OADAS,EAAMiB,WAAanC,KACZ,CAACoC,GAAYpB,IAGtB,IAAM8B,EAAuBtC,EAAQ1W,MAAMmD,GAC3C,OAAI8V,GAAUD,GAELA,EAAqB/X,MAAK,SAACiY,GAEhC,OADAlY,EAAKmY,WAAWJ,EAAiBG,EAAahC,GACvC6B,CACT,KAGFnnB,KAAKunB,WAAWJ,EAAiBC,EAAsB9B,GAChD6B,IACRrlB,EAEOylB,WAAR,SACEJ,EACAG,EACAhC,GAEA,IAAQnT,EAAgDmV,EAAhDnV,WAAYC,EAAoCkV,EAApClV,WAAYV,EAAwB4V,EAAxB5V,SAAUW,EAAciV,EAAdjV,UAC1CmV,EAA2CxnB,KAAKmlB,qBAAxCpI,EAAkByK,EAAlBzK,mBAAoBxL,EAAUiW,EAAVjW,WAC5BnK,EAAOtB,IAAG,qCAC6Bwf,EAAUlM,IAC7CkM,EAAUkB,MAAQ,EAAI,OAASlB,EAAUkB,KAAO,IACrClB,aAAAA,EAAUmC,OAEzB,IAAMC,EAAc1nB,KAAK+kB,QAASjI,MAChC3K,EACAC,EACAV,EACAW,EACAd,EACAwL,GACA,EACA/c,KAAK2G,IAEPwgB,EAAgBnc,KAAK,CACnB0c,YAAAA,EACApC,UAAAA,IAGFA,EAAUG,YAAYgB,WAAanC,MACpCxiB,EAEDklB,sBAAA,SAAsBhB,GACpB,IAAQlB,EAAqB9kB,KAArB8kB,QAASC,EAAY/kB,KAAZ+kB,QACZD,GAAYC,IAGjBD,EAAQ7T,eAAe+U,GACvBjB,EAAQ9T,eAAe+U,KACxBlkB,EAEDqP,gBAAA,WACE,IAAQ2T,EAAqB9kB,KAArB8kB,QAASC,EAAY/kB,KAAZ+kB,QACZD,GAAYC,IAGjBD,EAAQ3T,kBACR4T,EAAQ1I,uBACTva,EAED8O,iBAAA,SACEqV,EACAnV,EACAC,EACAC,EACAqU,GAEA,IAAQP,EAAqB9kB,KAArB8kB,QAASC,EAAY/kB,KAAZ+kB,QACZD,GAAYC,IAGjBD,EAAQlU,iBACNqV,EACAnV,EACAC,EACAC,GAEF+T,EAAQnU,iBACNqV,EACAnV,EACAC,EACAsU,KAEHvjB,EAEDoM,QAAA,WACMlO,KAAK8kB,UACP9kB,KAAK8kB,QAAQ5W,UACblO,KAAK8kB,aAAU5d,GAEblH,KAAK+kB,UACP/kB,KAAK+kB,QAAQ7W,UACblO,KAAK+kB,aAAU7d,IAElBpF,EAEOmlB,SAAR,SACE7mB,EACAmS,EACAhB,EACAwL,EACAuI,GAmBA,OAhBI/S,GAA8B,eAAnBA,EAAQ6T,OACZpmB,KAAK2nB,kBACZvnB,EACAmS,EACAhB,EACAwL,EACAuI,GAGOtlB,KAAK4nB,oBACZxnB,EACAmR,EACAwL,EACAuI,IAILxjB,EAEO8lB,oBAAR,SACExnB,EACAmR,EACAwL,EACAuI,GAEA,IAAAuC,EACE7nB,KAAK8kB,QACLxT,MAAMlR,EAAMmR,GAAY,GAAQvR,KAAKmN,OAAO2a,aAFtC3V,EAAU0V,EAAV1V,WAAYC,EAAUyV,EAAVzV,WAAYV,EAAQmW,EAARnW,SAAUW,EAASwV,EAATxV,UAa1C,MAAO,CACLqV,YAXkB1nB,KAAK+kB,QAASjI,MAChC3K,EACAC,EACAV,EACAW,EACAd,EACAwL,GACA,EACA/c,KAAK2G,IAIL2e,UAAAA,IAEHxjB,EAEO6lB,kBAAR,SACEvnB,EACA8lB,EACA3U,EACAwL,EACAuI,GAC2B,IAAAyC,EAAA/nB,KAC3B,OAAQA,KAAK8kB,QACVxS,eAAelS,EAAM8lB,EAAa3U,GAClClC,MAAK,SAACiY,GAWL,MAAO,CACLI,YAXkBK,EAAKhD,QAASjI,MAChCwK,EAAYnV,WACZmV,EAAYlV,WACZkV,EAAY5V,SACZ4V,EAAYjV,UACZd,EACAwL,GACA,EACAgL,EAAKphB,IAIL2e,UAAAA,EAEJ,KACHxjB,EAEO+kB,oBAAR,SAA4BzmB,GAI1B,IAHA,IAAQ+M,EAA4CnN,KAA5CmN,OAAQsO,EAAoCzb,KAApCyb,SAAUC,EAA0B1b,KAA1B0b,cAAeC,EAAW3b,KAAX2b,OAErCqM,EAAwB,KACnB5lB,EAAI,EAAGsK,EAAMiY,GAAUlhB,OAAQrB,EAAIsK,EAAKtK,IAC/C,GAAIuiB,GAAUviB,GAAGkP,MAAM8C,MAAMhU,GAAO,CAClC4nB,EAAMrD,GAAUviB,GAChB,KACF,CAEF,IAAK4lB,EACH,OAAO,IAAItkB,MAAM,mDAGnB,IAAMohB,EAAU9kB,KAAK8kB,QACfC,EAAU/kB,KAAK+kB,QACfkD,EAAUD,EAAIlL,MACdoL,EAAUF,EAAI1W,MACfyT,GAAaA,aAAmBkD,IACnCjoB,KAAK+kB,QAAU,IAAIkD,EAAQxM,EAAUtO,EAAQuO,EAAeC,IAEzDmJ,GAAaA,aAAmBoD,IACnCloB,KAAK8kB,QAAU,IAAIoD,EAAQzM,EAAUtO,EAAQuO,GAC7C1b,KAAKoU,MAAQ8T,EAAQ9T,QAExBtS,EAEO8kB,aAAR,SAAqBf,EAAwBC,GAG3C,OAAQ9lB,KAAK8kB,UAAY9kB,KAAK+kB,SAAWc,GAAiBC,GAC3DhkB,EAEOwkB,aAAR,WACE,IAAItB,EAAYhlB,KAAKglB,UAIrB,OAHKA,IACHA,EAAYhlB,KAAKglB,UAAY,IAAI9X,EAAUlN,KAAKmN,SAE3C6X,GACRJ,CAAA,CA7Z4B,GAib/B,IAAM8B,GAAc,SAACpB,GAAS,MAAwB,CACpDoC,YAAa,CAAE,EACfpC,UAAAA,EACD,EAEM,SAAS+B,GAAac,GAC3B,MAAO,SAAUA,GAAKA,EAAE9Y,gBAAgB+Y,QAC1C,kCC/dA,IAAIC,EAAMnJ,OAAOhf,UAAU2X,eACvByQ,EAAS,IASb,SAAS5oB,IAAW,CA4BpB,SAAS6oB,EAAGC,EAAIC,EAASC,GACvB1oB,KAAKwoB,GAAKA,EACVxoB,KAAKyoB,QAAUA,EACfzoB,KAAK0oB,KAAOA,IAAQ,CACrB,CAaD,SAASC,EAAYC,EAASC,EAAOL,EAAIC,EAASC,GAChD,GAAkB,mBAAPF,EACT,MAAM,IAAIM,UAAU,mCAGtB,IAAIC,EAAW,IAAIR,EAAGC,EAAIC,GAAWG,EAASF,GAC1CM,EAAMV,EAASA,EAASO,EAAQA,EAMpC,OAJKD,EAAQK,QAAQD,GACXJ,EAAQK,QAAQD,GAAKR,GAC1BI,EAAQK,QAAQD,GAAO,CAACJ,EAAQK,QAAQD,GAAMD,GADhBH,EAAQK,QAAQD,GAAKhe,KAAK+d,IADlCH,EAAQK,QAAQD,GAAOD,EAAUH,EAAQM,gBAI7DN,CACR,CASD,SAASO,EAAWP,EAASI,GACI,KAAzBJ,EAAQM,aAAoBN,EAAQK,QAAU,IAAIvpB,SAC5CkpB,EAAQK,QAAQD,EAC7B,CASD,SAASI,IACPppB,KAAKipB,QAAU,IAAIvpB,EACnBM,KAAKkpB,aAAe,CACrB,CAzEGhK,OAAOmK,SACT3pB,EAAOQ,UAAYgf,OAAOmK,OAAO,OAM5B,IAAI3pB,GAAS4pB,YAAWhB,GAAS,IA2ExCc,EAAalpB,UAAUqpB,WAAa,WAClC,IACIC,EACAlpB,EAFAmpB,EAAQ,GAIZ,GAA0B,IAAtBzpB,KAAKkpB,aAAoB,OAAOO,EAEpC,IAAKnpB,KAASkpB,EAASxpB,KAAKipB,QACtBZ,EAAIpnB,KAAKuoB,EAAQlpB,IAAOmpB,EAAMze,KAAKsd,EAAShoB,EAAKS,MAAM,GAAKT,GAGlE,OAAI4e,OAAOwK,sBACFD,EAAMjQ,OAAO0F,OAAOwK,sBAAsBF,IAG5CC,CACT,EASAL,EAAalpB,UAAUypB,UAAY,SAAmBd,GACpD,IAAIG,EAAMV,EAASA,EAASO,EAAQA,EAChCe,EAAW5pB,KAAKipB,QAAQD,GAE5B,IAAKY,EAAU,MAAO,GACtB,GAAIA,EAASpB,GAAI,MAAO,CAACoB,EAASpB,IAElC,IAAK,IAAIpmB,EAAI,EAAGynB,EAAID,EAASnmB,OAAQqmB,EAAK,IAAI9oB,MAAM6oB,GAAIznB,EAAIynB,EAAGznB,IAC7D0nB,EAAG1nB,GAAKwnB,EAASxnB,GAAGomB,GAGtB,OAAOsB,CACT,EASAV,EAAalpB,UAAU6pB,cAAgB,SAAuBlB,GAC5D,IAAIG,EAAMV,EAASA,EAASO,EAAQA,EAChCc,EAAY3pB,KAAKipB,QAAQD,GAE7B,OAAKW,EACDA,EAAUnB,GAAW,EAClBmB,EAAUlmB,OAFM,CAGzB,EASA2lB,EAAalpB,UAAU4gB,KAAO,SAAc+H,EAAOmB,EAAIC,EAAIC,EAAIC,EAAIC,GACjE,IAAIpB,EAAMV,EAASA,EAASO,EAAQA,EAEpC,IAAK7oB,KAAKipB,QAAQD,GAAM,OAAO,EAE/B,IAEIqB,EACAjoB,EAHAunB,EAAY3pB,KAAKipB,QAAQD,GACzBtc,EAAM7F,UAAUpD,OAIpB,GAAIkmB,EAAUnB,GAAI,CAGhB,OAFImB,EAAUjB,MAAM1oB,KAAKsqB,eAAezB,EAAOc,EAAUnB,QAAIthB,GAAW,GAEhEwF,GACN,KAAK,EAAG,OAAOid,EAAUnB,GAAGvnB,KAAK0oB,EAAUlB,UAAU,EACrD,KAAK,EAAG,OAAOkB,EAAUnB,GAAGvnB,KAAK0oB,EAAUlB,QAASuB,IAAK,EACzD,KAAK,EAAG,OAAOL,EAAUnB,GAAGvnB,KAAK0oB,EAAUlB,QAASuB,EAAIC,IAAK,EAC7D,KAAK,EAAG,OAAON,EAAUnB,GAAGvnB,KAAK0oB,EAAUlB,QAASuB,EAAIC,EAAIC,IAAK,EACjE,KAAK,EAAG,OAAOP,EAAUnB,GAAGvnB,KAAK0oB,EAAUlB,QAASuB,EAAIC,EAAIC,EAAIC,IAAK,EACrE,KAAK,EAAG,OAAOR,EAAUnB,GAAGvnB,KAAK0oB,EAAUlB,QAASuB,EAAIC,EAAIC,EAAIC,EAAIC,IAAK,EAG3E,IAAKhoB,EAAI,EAAGioB,EAAO,IAAIrpB,MAAM0L,EAAK,GAAItK,EAAIsK,EAAKtK,IAC7CioB,EAAKjoB,EAAI,GAAKyE,UAAUzE,GAG1BunB,EAAUnB,GAAG/T,MAAMkV,EAAUlB,QAAS4B,EAC1C,KAAS,CACL,IACIzJ,EADAnd,EAASkmB,EAAUlmB,OAGvB,IAAKrB,EAAI,EAAGA,EAAIqB,EAAQrB,IAGtB,OAFIunB,EAAUvnB,GAAGsmB,MAAM1oB,KAAKsqB,eAAezB,EAAOc,EAAUvnB,GAAGomB,QAAIthB,GAAW,GAEtEwF,GACN,KAAK,EAAGid,EAAUvnB,GAAGomB,GAAGvnB,KAAK0oB,EAAUvnB,GAAGqmB,SAAU,MACpD,KAAK,EAAGkB,EAAUvnB,GAAGomB,GAAGvnB,KAAK0oB,EAAUvnB,GAAGqmB,QAASuB,GAAK,MACxD,KAAK,EAAGL,EAAUvnB,GAAGomB,GAAGvnB,KAAK0oB,EAAUvnB,GAAGqmB,QAASuB,EAAIC,GAAK,MAC5D,KAAK,EAAGN,EAAUvnB,GAAGomB,GAAGvnB,KAAK0oB,EAAUvnB,GAAGqmB,QAASuB,EAAIC,EAAIC,GAAK,MAChE,QACE,IAAKG,EAAM,IAAKzJ,EAAI,EAAGyJ,EAAO,IAAIrpB,MAAM0L,EAAK,GAAIkU,EAAIlU,EAAKkU,IACxDyJ,EAAKzJ,EAAI,GAAK/Z,UAAU+Z,GAG1B+I,EAAUvnB,GAAGomB,GAAG/T,MAAMkV,EAAUvnB,GAAGqmB,QAAS4B,GAGnD,CAED,OAAO,CACT,EAWAjB,EAAalpB,UAAUqqB,GAAK,SAAY1B,EAAOL,EAAIC,GACjD,OAAOE,EAAY3oB,KAAM6oB,EAAOL,EAAIC,GAAS,EAC/C,EAWAW,EAAalpB,UAAUwoB,KAAO,SAAcG,EAAOL,EAAIC,GACrD,OAAOE,EAAY3oB,KAAM6oB,EAAOL,EAAIC,GAAS,EAC/C,EAYAW,EAAalpB,UAAUoqB,eAAiB,SAAwBzB,EAAOL,EAAIC,EAASC,GAClF,IAAIM,EAAMV,EAASA,EAASO,EAAQA,EAEpC,IAAK7oB,KAAKipB,QAAQD,GAAM,OAAOhpB,KAC/B,IAAKwoB,EAEH,OADAW,EAAWnpB,KAAMgpB,GACVhpB,KAGT,IAAI2pB,EAAY3pB,KAAKipB,QAAQD,GAE7B,GAAIW,EAAUnB,GAEVmB,EAAUnB,KAAOA,GACfE,IAAQiB,EAAUjB,MAClBD,GAAWkB,EAAUlB,UAAYA,GAEnCU,EAAWnpB,KAAMgpB,OAEd,CACL,IAAK,IAAI5mB,EAAI,EAAGonB,EAAS,GAAI/lB,EAASkmB,EAAUlmB,OAAQrB,EAAIqB,EAAQrB,KAEhEunB,EAAUvnB,GAAGomB,KAAOA,GACnBE,IAASiB,EAAUvnB,GAAGsmB,MACtBD,GAAWkB,EAAUvnB,GAAGqmB,UAAYA,IAErCe,EAAOxe,KAAK2e,EAAUvnB,IAOtBonB,EAAO/lB,OAAQzD,KAAKipB,QAAQD,GAAyB,IAAlBQ,EAAO/lB,OAAe+lB,EAAO,GAAKA,EACpEL,EAAWnpB,KAAMgpB,EACvB,CAED,OAAOhpB,IACT,EASAopB,EAAalpB,UAAUsqB,mBAAqB,SAA4B3B,GACtE,IAAIG,EAUJ,OARIH,GACFG,EAAMV,EAASA,EAASO,EAAQA,EAC5B7oB,KAAKipB,QAAQD,IAAMG,EAAWnpB,KAAMgpB,KAExChpB,KAAKipB,QAAU,IAAIvpB,EACnBM,KAAKkpB,aAAe,GAGflpB,IACT,EAKAopB,EAAalpB,UAAUuqB,IAAMrB,EAAalpB,UAAUoqB,eACpDlB,EAAalpB,UAAUyoB,YAAcS,EAAalpB,UAAUqqB,GAK5DnB,EAAasB,SAAWpC,EAKxBc,EAAaA,aAAeA,EAM1BuB,EAAAC,QAAiBxB,4BChNnB,SAASyB,GACPvkB,EACAwkB,GAEA,MAgDqBpD,EAhDHoD,EAAepD,aAkDlBvP,OACZuP,EAAYxP,OACZwP,EAAYjc,MACZic,EAAYzK,KACZyK,EAAY7W,aArDb,OAAO,EA+CX,IAAuB6W,EA7CfqD,EAAmC,GACzCC,EAAyBF,EAAepD,YAAhCvP,EAAK6S,EAAL7S,MAAOD,EAAK8S,EAAL9S,MAWf,OAVIC,GACF8S,GAAkBF,EAAc5S,GAE9BD,GACF+S,GAAkBF,EAAc7S,GAElC5R,EAAK4kB,YACH,CAAErC,MAAO,mBAAoBzoB,KAAM0qB,GACnCC,IAEK,CACT,CAIA,SAASE,GACPF,EACA1Z,GAEIA,EAAMvE,OACRie,EAAa/f,KAAKqG,EAAMvE,MAAMrH,QAE5B4L,EAAMtE,OACRge,EAAa/f,KAAKqG,EAAMtE,MAAMtH,OAElC,CAEA,SAAS0lB,GACP7kB,EACA8kB,EACA9F,GAEe8F,EAAQ1O,QACrB,SAAC2O,EAAQlc,GAAM,OAAK0b,GAAqBvkB,EAAM6I,IAAWkc,CAAM,IAChE,IAIA/kB,EAAK4kB,YAAY,CAAErC,MAAO,mBAAoBzoB,KAAMgrB,EAAQ,KAE9D9kB,EAAK4kB,YAAY,CAAErC,MAAO,QAASzoB,KAAMklB,GAC3C,EApKA,SAAqBhf,GACnB,IAAMmV,EAAW,IAAI2N,GACfkC,EAAiB,SAACC,EAAInrB,GAC1BkG,EAAK4kB,YAAY,CAAErC,MAAO0C,EAAInrB,KAAMA,KAItCqb,EAAS8O,GAAG7qB,EAAO8rB,eAAgBF,GACnC7P,EAAS8O,GAAG7qB,EAAOqhB,MAAOuK,GAG1B,IAAMG,EAAoB,WAAM,IAAAC,EAAA,SAAAC,GAE5B,IAAMtlB,EAAqB,SAACoJ,GAC1B6b,EAAe,YAAa,CAC1BM,QAASD,EACTlc,QAAAA,KAIJrI,EAAOukB,GAAStlB,GARlB,IAAK,IAAMslB,KAASvkB,EAAMskB,EAAAC,IAY5BrlB,EAAKulB,iBAAiB,WAAW,SAACN,GAChC,IAAMnrB,EAAOmrB,EAAGnrB,KAChB,OAAQA,EAAK0rB,KACX,IAAK,OACH,IAAM3e,EAAS4e,KAAKC,MAAM5rB,EAAK+M,QAC/B7G,EAAK2lB,WAAa,IAAIrH,GACpBnJ,EACArb,EAAKsb,cACLvO,EACA/M,EAAKub,OACLvb,EAAKuG,IAEPF,EAAW0G,EAAOtH,MAAOzF,EAAKuG,IAC9B8kB,IACAH,EAAe,OAAQ,MACvB,MAEF,IAAK,YACHhlB,EAAK2lB,WAAW7G,UAAUhlB,EAAK+M,QAC/B,MAEF,IAAK,QACH,IAAM2d,EACJxkB,EAAK2lB,WAAWjhB,KACd5K,EAAKA,KACLA,EAAKilB,YACLjlB,EAAKklB,UACLllB,EAAKmlB,OAEL8B,GAAUyD,IACZxkB,EAAK2lB,WAAWpH,OAAQ,EACxBiG,EACGzb,MAAK,SAACjP,GACLyqB,GAAqBvkB,EAAMlG,EAC7B,IACCmP,OAAM,SAACtJ,GACNqlB,EAAe5rB,EAAOqhB,MAAO,CAC3B3a,KAAMzG,EAAWmnB,YACjB7F,QAASrhB,EAAamnB,mBACtBzB,UAAWllB,EAAKklB,UAChBnE,OAAO,EACPlb,MAAAA,EACAuJ,IAAKvJ,EACLmb,OAAM,gCAEV,MAEF9a,EAAK2lB,WAAWpH,OAAQ,EACxBgG,GAAqBvkB,EAAMwkB,IAE7B,MAEF,IAAK,QACH,IAAMnkB,EAAKvG,EAAKklB,UACZwF,EAAiBxkB,EAAK2lB,WAAW7d,MAAMzH,GACxB0gB,GAAUyD,IACXxkB,EAAK2lB,WAAWpH,OAC3BwC,GAAUyD,KACbA,EAAiBpc,QAAQC,QAAQmc,IAEnCA,EACGzb,MAAK,SAAC+b,GACLD,GAAkB7kB,EAAM8kB,EAAoCzkB,EAC9D,IACC4I,OAAM,SAACtJ,GACNqlB,EAAe5rB,EAAOqhB,MAAO,CAC3B3a,KAAMzG,EAAWmnB,YACjB7F,QAASrhB,EAAamnB,mBACtBzB,UAAWllB,EAAKklB,UAChBnE,OAAO,EACPlb,MAAAA,EACAuJ,IAAKvJ,EACLmb,OAAM,iCAEV,KAEF+J,GACE7kB,EACAwkB,EACAnkB,GAQV,GACF,CAnHEulB,CAAY5lB","x_google_ignoreList":[8,23]}